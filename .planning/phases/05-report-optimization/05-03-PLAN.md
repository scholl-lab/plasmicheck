---
phase: 05-report-optimization
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - plasmicheck/scripts/generate_summary_reports.py
  - plasmicheck/templates/summary_template.html
autonomous: true

must_haves:
  truths:
    - "Default summary_reports run generates interactive HTML but NO PNG files and NO non-interactive HTML"
    - "Summary interactive HTML references shared plotly.min.js via relative path (directory mode)"
    - "With --static-report, PNGs and non-interactive summary HTML are generated alongside interactive"
    - "With --plotly-mode cdn, summary HTML uses CDN; with embedded, embeds plotly.js inline"
    - "pandas, plotly, numpy, scipy, statsmodels, jinja2 imports are at function level, not module level"
    - "Kaleido start_sync_server() is called once before any write_image() when --static-report is used"
  artifacts:
    - path: "plasmicheck/scripts/generate_summary_reports.py"
      provides: "Multi-sample summary report generation with conditional PNG, plotly mode, lazy imports"
      contains: "static_report"
    - path: "plasmicheck/templates/summary_template.html"
      provides: "Plotly.js mode-aware summary HTML template with CDN fallback"
      contains: "plotly_mode"
  key_links:
    - from: "plasmicheck/scripts/generate_summary_reports.py"
      to: "plasmicheck/templates/summary_template.html"
      via: "Jinja2 render with plotly_mode and plotly_version context vars"
      pattern: "plotly_mode.*plotly_version"
    - from: "plasmicheck/scripts/generate_summary_reports.py"
      to: "kaleido"
      via: "Conditional import and start_sync_server() when static_report=True"
      pattern: "start_sync_server"
---

<objective>
Refactor generate_summary_reports.py to implement conditional PNG export, plotly.js inclusion modes, lazy imports, and Kaleido performance optimization for multi-sample summary reports.

Purpose: Applies the same optimization pattern from Plan 02 to summary reports. Summary reports have even more plots (boxplot + heatmap) and heavier imports (numpy, scipy, statsmodels), so lazy imports have greater impact here.

Output: Refactored generate_summary_reports.py with new parameters, updated summary_template.html with plotly.js mode support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-report-optimization/05-CONTEXT.md
@.planning/phases/05-report-optimization/05-RESEARCH.md
@.planning/phases/05-report-optimization/05-01-SUMMARY.md

Source files:
@plasmicheck/scripts/generate_summary_reports.py
@plasmicheck/templates/summary_template.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor generate_summary_reports.py — lazy imports, conditional PNG, plotly.js modes</name>
  <files>plasmicheck/scripts/generate_summary_reports.py</files>
  <action>
Apply the same refactoring pattern as Plan 02's generate_report.py, adapted for summary reports:

**A. Lazy imports — move heavy imports to function level:**

Remove these module-level imports:
```python
# REMOVE from top of file:
import numpy as np
import pandas as pd
import plotly.express as px
import scipy.stats as stats
from jinja2 import Environment, FileSystemLoader
from statsmodels.stats.multitest import multipletests
```

Keep lightweight module-level imports:
```python
from __future__ import annotations
import base64
import logging
import os
import sys
from datetime import datetime, timezone
from typing import Any
from plasmicheck.config import get_config
from plasmicheck.resources import get_resource_path
from plasmicheck.version import __version__ as VERSION
from .utils import add_logging_args, configure_logging_from_args
```

Add function-level imports:
- `import pandas as pd` in: read_compare_outputs, apply_sorting, _sanitize_for_excel, save_tables_as_tsv_and_excel, calculate_variations, plot_boxplot, plot_heatmap, generate_report, main
- `import numpy as np` in: calculate_variations, plot_boxplot (where np is used)
- `import plotly.express as px` in: plot_boxplot, plot_heatmap
- `import scipy.stats as stats` in: calculate_variations
- `from statsmodels.stats.multitest import multipletests` in: calculate_variations
- `from jinja2 import Environment, FileSystemLoader` in: generate_report

Note: Several functions reference `pd.DataFrame` in type hints. With `from __future__ import annotations` already present, type hints are strings and don't require the import at evaluation time. So function-level imports work fine.

**B. Update plot_boxplot() for conditional PNG:**

Change signature:
```python
def plot_boxplot(
    boxplot_data: pd.DataFrame,
    output_dir: str,
    static_report: bool = False,
    plotly_mode: str = "directory",
) -> tuple[str, str | None]:
```

Return type changes: PNG filename is now Optional.

Inside:
- Always generate interactive HTML. Use `fig.write_html(boxplot_filename, include_plotlyjs=False, full_html=False)` (plots are embedded into report template)
- Only generate PNG when static_report=True:
  ```python
  boxplot_filename_png = None
  if static_report:
      boxplot_filename_png = os.path.join(plots_dir, "boxplot_contamination_ratios.png")
      fig.write_image(boxplot_filename_png)
  ```

**C. Update plot_heatmap() for conditional PNG:**

Same pattern:
```python
def plot_heatmap(
    ratio_df: pd.DataFrame,
    output_dir: str,
    threshold: float,
    unclear_range: dict[str, float],
    plot_config: dict[str, Any],
    static_report: bool = False,
    plotly_mode: str = "directory",
) -> tuple[str, str | None]:
```

- Always generate interactive HTML with `include_plotlyjs=False, full_html=False`
- Only generate PNG when static_report=True

**D. Update generate_report() for conditional non-interactive report:**

Change signature to accept static_report, plotly_mode, plotly_js_path (relative path to assets/plotly.min.js), and plotly_version:
```python
def generate_report(
    ...existing params...,
    static_report: bool = False,
    plotly_mode: str = "directory",
    plotly_js_path: str = "",
    plotly_version: str = "",
) -> None:
```

Inside:
- Always generate interactive HTML report
- Pass plotly_mode, plotly_version, and plotly_js_path to template render
- For embedded mode, read plotly.min.js content and pass as `plotly_js_inline`
- Only generate non-interactive HTML report when static_report=True
- Only read PNG files for base64 encoding when static_report=True

Handle the boxplot_filename_png and heatmap_filename_png being potentially None:
```python
if static_report and heatmap_filename_png and boxplot_filename_png:
    heatmap_png_base64 = encode_image_to_base64(heatmap_filename_png)
    boxplot_png_base64 = encode_image_to_base64(boxplot_filename_png)
    # Render non-interactive report
    ...
```

**E. Update main() to accept and forward new flags:**

```python
def main(
    input_dir: str,
    output_dir: str,
    threshold: float = DEFAULT_THRESHOLD,
    unclear_range: dict[str, float] = UNCLEAR_RANGE,
    substring_to_remove: str | None = None,
    static_report: bool = False,
    plotly_mode: str = "directory",
) -> None:
```

Inside main():
- If static_report is True, initialize kaleido once before any plotting:
  ```python
  if static_report:
      import kaleido
      kaleido.start_sync_server()
  ```
- Pass static_report and plotly_mode to plot_boxplot() and plot_heatmap()
- For directory mode, manage the shared plotly.min.js asset:
  ```python
  plotly_js_path = ""
  plotly_version = ""
  if plotly_mode in ("directory", "cdn"):
      import plotly
      plotly_version = plotly.__version__
  if plotly_mode == "directory":
      # Copy plotly.min.js to output_dir/assets/
      assets_dir = os.path.join(output_dir, "assets")
      os.makedirs(assets_dir, exist_ok=True)
      dest = os.path.join(assets_dir, "plotly.min.js")
      if not os.path.exists(dest):
          import shutil
          plotly_dir = os.path.dirname(plotly.__file__)
          source = os.path.join(plotly_dir, "package_data", "plotly.min.js")
          shutil.copy2(source, dest)
      plotly_js_path = "assets/plotly.min.js"  # Relative from output_dir
  ```
- Pass plotly_js_path and plotly_version to generate_report()

**F. Update __main__ block:**

Add --static-report and --plotly-mode flags, pass to main().

**Key anti-patterns to avoid:**
- Do NOT import kaleido at module level
- Do NOT call start_sync_server() inside each plot function — call it once in main() before all plotting
- Do NOT use include_plotlyjs='directory' from Plotly (copies per-directory) — manually manage shared assets/
  </action>
  <verify>
Run `make lint` — no ruff errors.
Run `make typecheck` — no new mypy errors.
Run `make test-fast` — existing tests pass (test_generate_summary_reports.py tests pure functions like apply_sorting, calculate_variations, find_tsv_files which don't change behavior).
Run `python -c "from plasmicheck.scripts.generate_summary_reports import main; import inspect; print(inspect.signature(main))"` — confirm new parameters.
  </verify>
  <done>
generate_summary_reports.py has lazy imports (pandas, numpy, plotly, scipy, statsmodels, jinja2 at function level), conditional PNG export gated behind static_report, plotly.js mode support, and Kaleido start_sync_server() optimization. Default behavior generates only interactive HTML summary report.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update summary_template.html for plotly.js mode support</name>
  <files>plasmicheck/templates/summary_template.html</files>
  <action>
Apply the same template changes as Plan 02's report_template.html, adapted for summary reports.

Replace the `<head>` section with plotly.js mode-aware loading:

```html
<head>
    <meta charset="UTF-8">
    <title>plasmicheck Summary Report</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.datatables.net/1.10.21/css/jquery.dataTables.min.css">

    {% if plotly_mode is not defined %}{% set plotly_mode = 'embedded' %}{% endif %}

    {% if plotly_mode == 'cdn' %}
        <script src="https://cdn.plot.ly/plotly-{{ plotly_version }}.min.js"></script>
    {% elif plotly_mode == 'directory' %}
        <script src="{{ plotly_js_path }}"></script>
        <script>
        if (typeof Plotly === 'undefined') {
            document.write('<script src="https://cdn.plot.ly/plotly-{{ plotly_version }}.min.js"><\/script>');
        }
        </script>
    {% elif plotly_mode == 'embedded' %}
        {{ plotly_js_inline|safe }}
    {% endif %}

    <style>
        body { margin: 20px; }
        h1, h2, h3 { text-align: center; margin-top: 20px; }
        .container { margin-top: 20px; }
        .table-container { width: 80%; margin: 20px auto; }
        .plot { margin: 20px auto; display: block; width: 80%; }
        .logo { display: block; margin: 0 auto; width: 150px; }
    </style>
</head>
```

Keep the body section the same — the interactive/non-interactive conditionals work as before. The plot content (heatmap_content, boxplot_content) will now be div+script fragments for interactive mode (instead of full HTML with embedded plotly.js).

Keep the jQuery/DataTables scripts at the bottom of the body unchanged — they're separate from plotly.

Ensure the `plotly_mode is not defined` fallback is present for backwards compatibility.
  </action>
  <verify>
Read the updated template and verify:
1. Jinja2 conditionals for plotly_mode are syntactically correct
2. CDN fallback pattern present for directory mode
3. Embedded mode has script injection point
4. CSS styles and DataTables scripts preserved from original
5. Plot rendering sections unchanged

Run `make test-fast` to confirm no regressions.
  </verify>
  <done>
summary_template.html loads plotly.js conditionally based on plotly_mode (cdn, directory with CDN fallback, embedded). DataTables and Bootstrap CSS preserved. Backwards compatible with undefined plotly_mode.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from plasmicheck.scripts.generate_summary_reports import main"` succeeds (no import-time errors)
2. `make lint` passes
3. `make typecheck` passes
4. `make test-fast` passes
5. generate_summary_reports.main() signature includes static_report and plotly_mode
6. summary_template.html contains plotly_mode conditionals and CDN fallback
</verification>

<success_criteria>
- REPT-01 (summary): Default summary_reports run skips PNG generation
- REPT-02 (summary): summary_reports generates PNGs when static_report=True
- REPT-03 (summary): Summary reports support directory mode with shared plotly.min.js
- REPT-04 (summary): Summary reports support cdn/directory/embedded modes
- REPT-05 (summary): Kaleido start_sync_server() called once before plotting when static_report=True
- REPT-06 (summary): All heavy imports (pandas, numpy, plotly, scipy, statsmodels, jinja2) at function level
- Summary template correctly handles all three plotly.js modes
</success_criteria>

<output>
After completion, create `.planning/phases/05-report-optimization/05-03-SUMMARY.md`
</output>
