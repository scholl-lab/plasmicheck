---
phase: 05-report-optimization
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - plasmicheck/scripts/generate_summary_reports.py
  - plasmicheck/templates/summary_template.html
autonomous: true

must_haves:
  truths:
    - "Default summary_reports run generates interactive HTML but NO PNG files and NO non-interactive HTML"
    - "Summary interactive HTML references shared plotly.min.js via relative path (directory mode)"
    - "With --static-report, PNGs and non-interactive summary HTML are generated alongside interactive"
    - "With --plotly-mode cdn, summary HTML uses CDN; with embedded, embeds plotly.js inline"
    - "pandas, plotly, numpy, scipy, statsmodels, jinja2 imports are at function level, not module level"
    - "Kaleido start_sync_server() is called once before any write_image() when --static-report is used"
  artifacts:
    - path: "plasmicheck/scripts/generate_summary_reports.py"
      provides: "Multi-sample summary report generation with conditional PNG, plotly mode, lazy imports"
      contains: "static_report"
    - path: "plasmicheck/templates/summary_template.html"
      provides: "Plotly.js mode-aware summary HTML template with CDN fallback"
      contains: "plotly_mode"
  key_links:
    - from: "plasmicheck/scripts/generate_summary_reports.py"
      to: "plasmicheck/templates/summary_template.html"
      via: "Jinja2 render with plotly_mode and plotly_version context vars"
      pattern: "plotly_mode.*plotly_version"
    - from: "plasmicheck/scripts/generate_summary_reports.py"
      to: "kaleido"
      via: "Conditional import and start_sync_server() when static_report=True"
      pattern: "start_sync_server"
---

<objective>
Refactor generate_summary_reports.py to implement conditional PNG export, plotly.js inclusion modes, lazy imports, and Kaleido performance optimization for multi-sample summary reports.

Purpose: Applies the same optimization pattern from Plan 02 to summary reports. Summary reports have even more plots (boxplot + heatmap) and heavier imports (numpy, scipy, statsmodels), so lazy imports have greater impact here.

Output: Refactored generate_summary_reports.py with new parameters, updated summary_template.html with plotly.js mode support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-report-optimization/05-CONTEXT.md
@.planning/phases/05-report-optimization/05-RESEARCH.md
@.planning/phases/05-report-optimization/05-01-SUMMARY.md

Source files:
@plasmicheck/scripts/generate_summary_reports.py
@plasmicheck/templates/summary_template.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Lazy imports and conditional PNG export in generate_summary_reports.py</name>
  <files>plasmicheck/scripts/generate_summary_reports.py</files>
  <action>
This task handles the import restructuring, conditional PNG gating, and Kaleido optimization. The plotly.js asset management and template wiring are in Task 2.

**A. Lazy imports -- move heavy imports to function level:**

Remove these module-level imports:
```python
# REMOVE from top of file:
import numpy as np
import pandas as pd
import plotly.express as px
import scipy.stats as stats
from jinja2 import Environment, FileSystemLoader
from statsmodels.stats.multitest import multipletests
```

Keep lightweight module-level imports:
```python
from __future__ import annotations
import base64
import logging
import os
import sys
from datetime import datetime, timezone
from typing import Any
from plasmicheck.config import get_config
from plasmicheck.resources import get_resource_path
from plasmicheck.version import __version__ as VERSION
from .utils import add_logging_args, configure_logging_from_args
```

Add function-level imports:
- `import pandas as pd` in: read_compare_outputs, apply_sorting, _sanitize_for_excel, save_tables_as_tsv_and_excel, calculate_variations, plot_boxplot, plot_heatmap, generate_report, main
- `import numpy as np` in: calculate_variations, plot_boxplot (where np is used)
- `import plotly.express as px` in: plot_boxplot, plot_heatmap
- `import scipy.stats as stats` in: calculate_variations
- `from statsmodels.stats.multitest import multipletests` in: calculate_variations
- `from jinja2 import Environment, FileSystemLoader` in: generate_report

Note: With `from __future__ import annotations` already present, type hints are strings and don't require the import at evaluation time. So function-level imports work fine.

**B. Update plot_boxplot() for conditional PNG:**

Change signature:
```python
def plot_boxplot(
    boxplot_data: pd.DataFrame,
    output_dir: str,
    static_report: bool = False,
) -> tuple[str, str | None]:
```

Return type changes: PNG filename is now Optional.

Inside:
- Always generate interactive HTML. Use `fig.write_html(boxplot_filename, include_plotlyjs=False, full_html=False)` (plots are embedded into report template)
- Only generate PNG when static_report=True:
  ```python
  boxplot_filename_png = None
  if static_report:
      boxplot_filename_png = os.path.join(plots_dir, "boxplot_contamination_ratios.png")
      fig.write_image(boxplot_filename_png)
  ```

**C. Update plot_heatmap() for conditional PNG:**

Same pattern:
```python
def plot_heatmap(
    ratio_df: pd.DataFrame,
    output_dir: str,
    threshold: float,
    unclear_range: dict[str, float],
    plot_config: dict[str, Any],
    static_report: bool = False,
) -> tuple[str, str | None]:
```

- Always generate interactive HTML with `include_plotlyjs=False, full_html=False`
- Only generate PNG when static_report=True

**D. Update main() to accept and forward new flags:**

```python
def main(
    input_dir: str,
    output_dir: str,
    threshold: float = DEFAULT_THRESHOLD,
    unclear_range: dict[str, float] = UNCLEAR_RANGE,
    substring_to_remove: str | None = None,
    static_report: bool = False,
    plotly_mode: str = "directory",
) -> None:
```

Inside main():
- If static_report is True, initialize kaleido once before any plotting:
  ```python
  if static_report:
      import kaleido
      kaleido.start_sync_server()
  ```
- Pass static_report to plot_boxplot() and plot_heatmap()
- Handle boxplot_filename_png and heatmap_filename_png being potentially None in generate_report() call

**E. Update generate_report() for conditional non-interactive report:**

Change signature to accept static_report and plotly_mode:
```python
def generate_report(
    ...existing params...,
    static_report: bool = False,
    plotly_mode: str = "directory",
    plotly_js_path: str = "",
    plotly_version: str = "",
) -> None:
```

Inside:
- Always generate interactive HTML report
- Only generate non-interactive HTML report when static_report=True
- Only read PNG files for base64 encoding when static_report=True
- Handle the boxplot_filename_png and heatmap_filename_png being potentially None

**F. Update __main__ block:**

Add --static-report and --plotly-mode flags, pass to main().

**Key anti-patterns to avoid:**
- Do NOT import kaleido at module level
- Do NOT call start_sync_server() inside each plot function -- call it once in main() before all plotting
- Do NOT use include_plotlyjs='directory' from Plotly (copies per-directory)
  </action>
  <verify>
Run `make lint` -- no ruff errors.
Run `make typecheck` -- no new mypy errors.
Run `make test-fast` -- existing tests pass (test_generate_summary_reports.py tests pure functions like apply_sorting, calculate_variations, find_tsv_files which don't change behavior).
Run `python -c "from plasmicheck.scripts.generate_summary_reports import main; import inspect; print(inspect.signature(main))"` -- confirm new parameters.
  </verify>
  <done>
generate_summary_reports.py has lazy imports (pandas, numpy, plotly, scipy, statsmodels, jinja2 at function level), conditional PNG export gated behind static_report, and Kaleido start_sync_server() called once in main(). Default behavior generates only interactive HTML.
  </done>
</task>

<task type="auto">
  <name>Task 2: Plotly.js asset management and summary template wiring</name>
  <files>plasmicheck/scripts/generate_summary_reports.py, plasmicheck/templates/summary_template.html</files>
  <action>
This task adds plotly.js directory-mode asset management to generate_summary_reports.py and updates the summary template.

**A. Wire plotly.js management into main():**

In main(), after the kaleido setup:
```python
plotly_js_path = ""
plotly_version = ""
if plotly_mode in ("directory", "cdn"):
    import plotly
    plotly_version = plotly.__version__
if plotly_mode == "directory":
    # Copy plotly.min.js to output_dir/assets/
    assets_dir = os.path.join(output_dir, "assets")
    os.makedirs(assets_dir, exist_ok=True)
    dest = os.path.join(assets_dir, "plotly.min.js")
    if not os.path.exists(dest):
        import shutil
        plotly_dir = os.path.dirname(plotly.__file__)
        source = os.path.join(plotly_dir, "package_data", "plotly.min.js")
        shutil.copy2(source, dest)
    plotly_js_path = "assets/plotly.min.js"  # Relative from output_dir
```

Note: For summary_reports, the output_dir IS the root directory (unlike generate_report where output_folder is a subdirectory). So the assets/ path is simpler here -- no need for output_root.

For embedded mode, read the plotly.min.js content for inline injection:
```python
plotly_js_inline = ""
if plotly_mode == "embedded":
    import plotly as _plotly
    plotly_js_source = os.path.join(os.path.dirname(_plotly.__file__), "package_data", "plotly.min.js")
    with open(plotly_js_source) as f:
        plotly_js_inline = f"<script>{f.read()}</script>"
```

Pass plotly_js_path, plotly_version, and plotly_js_inline to generate_report().

**B. Update generate_report() to pass plotly context to template:**

In the Jinja2 render call, add the plotly template context variables:
```python
template.render(
    ...existing context...,
    plotly_mode=plotly_mode,
    plotly_version=plotly_version,
    plotly_js_path=plotly_js_path,
    plotly_js_inline=plotly_js_inline,
)
```

**C. Update summary_template.html for plotly.js mode support:**

Replace the `<head>` section with plotly.js mode-aware loading:

```html
<head>
    <meta charset="UTF-8">
    <title>plasmicheck Summary Report</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.datatables.net/1.10.21/css/jquery.dataTables.min.css">

    {% if plotly_mode is not defined %}{% set plotly_mode = 'embedded' %}{% endif %}

    {% if plotly_mode == 'cdn' %}
        <script src="https://cdn.plot.ly/plotly-{{ plotly_version }}.min.js"></script>
    {% elif plotly_mode == 'directory' %}
        <script src="{{ plotly_js_path }}"></script>
        <script>
        if (typeof Plotly === 'undefined') {
            document.write('<script src="https://cdn.plot.ly/plotly-{{ plotly_version }}.min.js"><\/script>');
        }
        </script>
    {% elif plotly_mode == 'embedded' %}
        {{ plotly_js_inline|safe }}
    {% endif %}

    <style>
        /* Preserve ALL existing CSS styles unchanged */
    </style>
</head>
```

Keep the body section the same -- the interactive/non-interactive conditionals work as before. The plot content (heatmap_content, boxplot_content) will now be div+script fragments for interactive mode.

Keep the jQuery/DataTables scripts at the bottom of the body unchanged.

The `plotly_mode is not defined` fallback ensures backwards compatibility.
  </action>
  <verify>
Run `make lint` -- no ruff errors.
Run `make typecheck` -- no new mypy errors.
Run `make test-fast` -- existing tests pass.
Read the updated template and verify:
1. Jinja2 conditionals for plotly_mode are syntactically correct
2. CDN fallback pattern present for directory mode
3. Embedded mode has script injection point
4. CSS styles and DataTables scripts preserved from original
5. Plot rendering sections unchanged
  </verify>
  <done>
generate_summary_reports.py has plotly.js asset management for directory mode, plotly context passed to template. summary_template.html loads plotly.js conditionally based on plotly_mode (cdn, directory with CDN fallback, embedded). DataTables and Bootstrap CSS preserved. Backwards compatible with undefined plotly_mode.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from plasmicheck.scripts.generate_summary_reports import main"` succeeds (no import-time errors)
2. `make lint` passes
3. `make typecheck` passes
4. `make test-fast` passes
5. generate_summary_reports.main() signature includes static_report and plotly_mode
6. summary_template.html contains plotly_mode conditionals and CDN fallback
</verification>

<success_criteria>
- REPT-01 (summary): Default summary_reports run skips PNG generation
- REPT-02 (summary): summary_reports generates PNGs when static_report=True
- REPT-03 (summary): Summary reports support directory mode with shared plotly.min.js
- REPT-04 (summary): Summary reports support cdn/directory/embedded modes
- REPT-05 (summary): Kaleido start_sync_server() called once before plotting when static_report=True
- REPT-06 (summary): All heavy imports (pandas, numpy, plotly, scipy, statsmodels, jinja2) at function level
- Summary template correctly handles all three plotly.js modes
</success_criteria>

<output>
After completion, create `.planning/phases/05-report-optimization/05-03-SUMMARY.md`
</output>
