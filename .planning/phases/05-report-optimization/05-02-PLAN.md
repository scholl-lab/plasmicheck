---
phase: 05-report-optimization
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - plasmicheck/scripts/generate_report.py
  - plasmicheck/templates/report_template.html
autonomous: true

must_haves:
  truths:
    - "Default pipeline run generates interactive HTML reports but NO PNG files and NO non-interactive HTML"
    - "Interactive HTML reports reference shared plotly.min.js via relative path (directory mode)"
    - "With --static-report flag, PNGs and non-interactive HTML are generated alongside interactive HTML"
    - "With --plotly-mode cdn, HTML uses CDN script tag; with embedded, HTML embeds plotly.js inline"
    - "pandas, plotly, jinja2 imports are at function level, not module level"
    - "Kaleido start_sync_server() is called once before write_image() when --static-report is used"
  artifacts:
    - path: "plasmicheck/scripts/generate_report.py"
      provides: "Single-sample report generation with conditional PNG, plotly mode, lazy imports"
      contains: "static_report"
    - path: "plasmicheck/templates/report_template.html"
      provides: "Plotly.js mode-aware HTML template with CDN fallback"
      contains: "plotly_mode"
  key_links:
    - from: "plasmicheck/scripts/generate_report.py"
      to: "plasmicheck/templates/report_template.html"
      via: "Jinja2 render with plotly_mode and plotly_version context vars"
      pattern: "plotly_mode.*plotly_version"
    - from: "plasmicheck/scripts/generate_report.py"
      to: "output/assets/plotly.min.js"
      via: "Copies plotly.min.js to assets/ directory for directory mode"
      pattern: "plotly\\.min\\.js"
    - from: "plasmicheck/scripts/generate_report.py"
      to: "kaleido"
      via: "Conditional import and start_sync_server() when static_report=True"
      pattern: "start_sync_server"
---

<objective>
Refactor generate_report.py to implement conditional PNG export, plotly.js inclusion modes, lazy imports, and Kaleido performance optimization for single-sample reports.

Purpose: This is the core performance optimization for single-sample report generation. Currently 91.7% of pipeline time is spent in report generation (primarily Kaleido PNG export). By making PNG export opt-in and using directory-mode plotly.js, we eliminate the bottleneck for default runs and reduce HTML size from 9.6 MB to ~19 KB.

Output: Refactored generate_report.py with new parameters, updated report_template.html with plotly.js mode support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-report-optimization/05-CONTEXT.md
@.planning/phases/05-report-optimization/05-RESEARCH.md
@.planning/phases/05-report-optimization/05-01-SUMMARY.md

Source files:
@plasmicheck/scripts/generate_report.py
@plasmicheck/templates/report_template.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Lazy imports and conditional PNG export in generate_report.py</name>
  <files>plasmicheck/scripts/generate_report.py</files>
  <action>
This task handles the import restructuring and conditional PNG gating. The plotly.js asset management and template wiring are in Task 2.

**A. Lazy imports -- move heavy imports to function level:**

Remove these module-level imports:
```python
# REMOVE from top of file:
import pandas as pd
import plotly.express as px
from jinja2 import Environment, FileSystemLoader
```

Keep these module-level imports (they're lightweight):
```python
from __future__ import annotations
import base64
import logging
import os
from datetime import datetime, timezone
from typing import Any
from plasmicheck.config import get_config
from plasmicheck.resources import get_resource_path
from plasmicheck.version import __version__ as VERSION
from .utils import add_logging_args, configure_logging_from_args
```

Add `import pandas as pd` inside every function that uses pandas (load_data, downsample_data, extract_verdict_from_summary, generate_report, main).
Add `import plotly.express as px` inside generate_plots().
Add `from jinja2 import Environment, FileSystemLoader` inside generate_report().

**B. Add static_report and plotly_mode parameters to generate_plots():**

Update `generate_plots()` signature:
```python
def generate_plots(
    reads_df: pd.DataFrame,
    output_folder: str,
    static_report: bool = False,
) -> tuple[str, str, str | None, str | None]:
```

The return type changes: PNG filenames are now Optional (None when static_report=False).

Inside generate_plots():
- Always generate interactive HTML plots. Use `include_plotlyjs=False` and `full_html=False` for ALL modes -- the plotly.js loading is handled by the report template's `<head>`, and the plots are div+script fragments embedded into the template.
  ```python
  fig_box.write_html(boxplot_filename_interactive, include_plotlyjs=False, full_html=False)
  ```
  Same for fig_scatter.

- Only generate PNGs when static_report=True:
  ```python
  boxplot_filename_png = None
  scatter_filename_png = None
  if static_report:
      import kaleido
      kaleido.start_sync_server()

      boxplot_filename_png = os.path.join(plots_dir, PLOT_SAMPLE_REPORT["output_box_plot_filename"])
      fig_box.write_image(boxplot_filename_png)

      scatter_filename_png = os.path.join(plots_dir, PLOT_SAMPLE_REPORT["output_scatter_plot_filename"])
      fig_scatter.write_image(scatter_filename_png)
  ```

**C. Update generate_report() for conditional non-interactive report:**

Update signature to accept static_report and plotly_mode:
```python
def generate_report(
    summary_df: pd.DataFrame,
    output_folder: str,
    ...existing params...,
    boxplot_filename_png: str | None = None,
    scatter_filename_png: str | None = None,
    ...
    static_report: bool = False,
    plotly_mode: str = "directory",
) -> None:
```

Changes inside generate_report():
- The interactive HTML report is ALWAYS generated
- Only generate non-interactive HTML report when `static_report=True`
- When static_report=False, skip reading PNG files and skip rendering non-interactive report

**D. Update main() to accept new parameters:**

```python
def main(
    reads_assignment_file: str,
    summary_file: str,
    output_folder: str,
    threshold: float = DEFAULT_THRESHOLD,
    unclear: dict[str, float] = UNCLEAR_RANGE,
    human_fasta: str = "None",
    plasmid_gb: str = "None",
    sequencing_file: str = "None",
    command_line: str = "",
    static_report: bool = False,
    plotly_mode: str = "directory",
    output_root: str | None = None,
) -> None:
```

Pass static_report through to generate_plots() and generate_report(). The output_root and plotly_mode parameters are wired in Task 2.

**E. Update the __main__ block:**

Add --static-report and --plotly-mode flags to the standalone argparse at the bottom of the file, and pass them to main().

**Key anti-patterns to avoid:**
- Do NOT import kaleido at module level -- only inside the `if static_report:` block.
- Do NOT use `type=bool` for argparse flags.
- Do NOT call `kaleido.start_sync_server()` without a subsequent `write_image()` -- only call it when PNGs will actually be generated.
  </action>
  <verify>
Run `make lint` -- no ruff errors.
Run `make typecheck` -- no new mypy errors.
Run `make test-fast` -- existing tests should still pass (they test load_data, downsample_data, extract_verdict which don't change behavior).
Run `python -c "from plasmicheck.scripts.generate_report import main; import inspect; print(inspect.signature(main))"` -- confirm new parameters.
  </verify>
  <done>
generate_report.py has lazy imports (pandas, plotly, jinja2 at function level), conditional PNG export gated behind static_report flag, and Kaleido start_sync_server() optimization. Default behavior skips PNG generation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Plotly.js asset management and template wiring</name>
  <files>plasmicheck/scripts/generate_report.py, plasmicheck/templates/report_template.html</files>
  <action>
This task adds the plotly.js directory-mode asset management to generate_report.py and updates the report template.

**A. Add plotly.js asset helper to generate_report.py:**

Add a helper function:
```python
def _ensure_plotly_assets(output_root: str) -> None:
    """Copy plotly.min.js to {output_root}/assets/ if not already present."""
    import plotly

    plotly_dir = os.path.dirname(plotly.__file__)
    plotly_js_source = os.path.join(plotly_dir, "package_data", "plotly.min.js")

    assets_dir = os.path.join(output_root, "assets")
    os.makedirs(assets_dir, exist_ok=True)

    dest = os.path.join(assets_dir, "plotly.min.js")
    if not os.path.exists(dest):
        import shutil
        shutil.copy2(plotly_js_source, dest)
        logging.info(f"Copied plotly.min.js to {dest}")
```

**B. Wire plotly.js management into main():**

In main(), after the existing setup:
```python
# Determine output_root for shared assets
effective_root = output_root if output_root else output_folder

plotly_js_path = ""
plotly_version = ""
if plotly_mode in ("directory", "cdn"):
    import plotly
    plotly_version = plotly.__version__
if plotly_mode == "directory":
    _ensure_plotly_assets(effective_root)
    # Compute relative path from output_folder to assets/plotly.min.js
    assets_js = os.path.join(effective_root, "assets", "plotly.min.js")
    plotly_js_path = os.path.relpath(assets_js, output_folder)
```

Pass `plotly_mode`, `plotly_version`, and `plotly_js_path` to the generate_report() internal function call. For embedded mode, read the plotly.min.js content and pass as `plotly_js_inline`:
```python
plotly_js_inline = ""
if plotly_mode == "embedded":
    import plotly as _plotly
    plotly_js_source = os.path.join(os.path.dirname(_plotly.__file__), "package_data", "plotly.min.js")
    with open(plotly_js_source) as f:
        plotly_js_inline = f"<script>{f.read()}</script>"
```

Pass these as template context variables in the generate_report() Jinja2 render call.

**C. Update report_template.html for plotly.js mode support:**

The current template renders `{{ box_plot|safe }}` and `{{ scatter_plot|safe }}` which were previously full HTML documents (from write_html with include_plotlyjs=True). Now the plots are div-only fragments (from write_html with include_plotlyjs=False, full_html=False), so the template must load plotly.js itself.

Replace the current `<head>` section with plotly.js mode-aware loading:

```html
<head>
    <meta charset="UTF-8">
    <title>plasmicheck Report</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">

    {% if plotly_mode is not defined %}{% set plotly_mode = 'embedded' %}{% endif %}

    {% if plotly_mode == 'cdn' %}
        <script src="https://cdn.plot.ly/plotly-{{ plotly_version }}.min.js"></script>
    {% elif plotly_mode == 'directory' %}
        <script src="{{ plotly_js_path }}"></script>
        <script>
        if (typeof Plotly === 'undefined') {
            document.write('<script src="https://cdn.plot.ly/plotly-{{ plotly_version }}.min.js"><\/script>');
        }
        </script>
    {% elif plotly_mode == 'embedded' %}
        {{ plotly_js_inline|safe }}
    {% endif %}

    <style>
        /* Preserve all existing CSS styles unchanged */
    </style>
</head>
```

The body section's interactive/non-interactive conditionals stay the same. The plot content (box_plot, scatter_plot) is now a div+script fragment for interactive mode.

The `plotly_mode is not defined` fallback ensures backwards compatibility if the template is rendered without the new variables.

**Key anti-patterns to avoid:**
- Do NOT use `include_plotlyjs='directory'` (Plotly's built-in) -- it copies plotly.min.js per plot directory. Manage the shared assets/ directory manually.
  </action>
  <verify>
Run `make lint` -- no ruff errors.
Run `make typecheck` -- no new mypy errors.
Run `make test-fast` -- existing tests should still pass.
Read the updated template and verify:
1. Jinja2 conditionals for plotly_mode are syntactically correct
2. CDN fallback pattern present for directory mode
3. Embedded mode has script injection point
4. CSS styles preserved from original
5. Plot rendering sections unchanged (interactive/non-interactive conditionals)
  </verify>
  <done>
generate_report.py has plotly.js asset management (_ensure_plotly_assets helper), output_root support for shared assets directory, and plotly mode context passed to template. report_template.html loads plotly.js conditionally based on plotly_mode: cdn mode uses CDN script tag, directory mode uses local path with CDN fallback, embedded mode uses inline plotly.js.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from plasmicheck.scripts.generate_report import main"` succeeds (no import-time errors from lazy imports)
2. `make lint` passes
3. `make typecheck` passes (or only has expected errors from generate_summary_reports.py not yet updated)
4. `make test-fast` passes
5. generate_report.main() signature includes static_report, plotly_mode, output_root parameters
6. report_template.html contains plotly_mode conditionals and CDN fallback
</verification>

<success_criteria>
- REPT-01 (partial): generate_report.py default path skips PNG generation
- REPT-02 (partial): generate_report.py generates PNGs when static_report=True
- REPT-03 (partial): generate_report.py supports directory mode with shared plotly.min.js
- REPT-04 (partial): generate_report.py supports cdn/directory/embedded modes
- REPT-05 (partial): Kaleido start_sync_server() called before write_image when static_report=True
- REPT-06 (partial): pandas, plotly, jinja2 imported at function level in generate_report.py
- Template correctly handles all three plotly.js modes
</success_criteria>

<output>
After completion, create `.planning/phases/05-report-optimization/05-02-SUMMARY.md`
</output>
