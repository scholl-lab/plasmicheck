---
phase: 05-report-optimization
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - plasmicheck/scripts/generate_report.py
  - plasmicheck/templates/report_template.html
autonomous: true

must_haves:
  truths:
    - "Default pipeline run generates interactive HTML reports but NO PNG files and NO non-interactive HTML"
    - "Interactive HTML reports reference shared plotly.min.js via relative path (directory mode)"
    - "With --static-report flag, PNGs and non-interactive HTML are generated alongside interactive HTML"
    - "With --plotly-mode cdn, HTML uses CDN script tag; with embedded, HTML embeds plotly.js inline"
    - "pandas, plotly, jinja2 imports are at function level, not module level"
    - "Kaleido start_sync_server() is called once before write_image() when --static-report is used"
  artifacts:
    - path: "plasmicheck/scripts/generate_report.py"
      provides: "Single-sample report generation with conditional PNG, plotly mode, lazy imports"
      contains: "static_report"
    - path: "plasmicheck/templates/report_template.html"
      provides: "Plotly.js mode-aware HTML template with CDN fallback"
      contains: "plotly_mode"
  key_links:
    - from: "plasmicheck/scripts/generate_report.py"
      to: "plasmicheck/templates/report_template.html"
      via: "Jinja2 render with plotly_mode and plotly_version context vars"
      pattern: "plotly_mode.*plotly_version"
    - from: "plasmicheck/scripts/generate_report.py"
      to: "output/assets/plotly.min.js"
      via: "Copies plotly.min.js to assets/ directory for directory mode"
      pattern: "plotly\\.min\\.js"
    - from: "plasmicheck/scripts/generate_report.py"
      to: "kaleido"
      via: "Conditional import and start_sync_server() when static_report=True"
      pattern: "start_sync_server"
---

<objective>
Refactor generate_report.py to implement conditional PNG export, plotly.js inclusion modes, lazy imports, and Kaleido performance optimization for single-sample reports.

Purpose: This is the core performance optimization for single-sample report generation. Currently 91.7% of pipeline time is spent in report generation (primarily Kaleido PNG export). By making PNG export opt-in and using directory-mode plotly.js, we eliminate the bottleneck for default runs and reduce HTML size from 9.6 MB to ~19 KB.

Output: Refactored generate_report.py with new parameters, updated report_template.html with plotly.js mode support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-report-optimization/05-CONTEXT.md
@.planning/phases/05-report-optimization/05-RESEARCH.md
@.planning/phases/05-report-optimization/05-01-SUMMARY.md

Source files:
@plasmicheck/scripts/generate_report.py
@plasmicheck/templates/report_template.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor generate_report.py — lazy imports, conditional PNG, plotly.js modes</name>
  <files>plasmicheck/scripts/generate_report.py</files>
  <action>
This is a significant refactor of generate_report.py. Follow these changes carefully:

**A. Lazy imports — move heavy imports to function level:**

Remove these module-level imports:
```python
# REMOVE from top of file:
import pandas as pd
import plotly.express as px
from jinja2 import Environment, FileSystemLoader
```

Keep these module-level imports (they're lightweight):
```python
from __future__ import annotations
import base64
import logging
import os
from datetime import datetime, timezone
from typing import Any
from plasmicheck.config import get_config
from plasmicheck.resources import get_resource_path
from plasmicheck.version import __version__ as VERSION
from .utils import add_logging_args, configure_logging_from_args
```

Add `import pandas as pd` inside every function that uses pandas (load_data, downsample_data, extract_verdict_from_summary, generate_report, main).
Add `import plotly.express as px` inside generate_plots().
Add `from jinja2 import Environment, FileSystemLoader` inside generate_report().

**B. Add static_report and plotly_mode parameters:**

Update `generate_plots()` signature:
```python
def generate_plots(
    reads_df: pd.DataFrame,
    output_folder: str,
    static_report: bool = False,
    plotly_mode: str = "directory",
) -> tuple[str, str, str | None, str | None]:
```

The return type changes: PNG filenames are now Optional (None when static_report=False).

Inside generate_plots():
- Always generate interactive HTML plots
- For `write_html()` calls, use the plotly_mode to control include_plotlyjs:
  - If plotly_mode == "directory": use `include_plotlyjs=False` (we'll handle plotly.js at the template level)
  - If plotly_mode == "cdn": use `include_plotlyjs=False` (template handles CDN)
  - If plotly_mode == "embedded": use `include_plotlyjs=True`

  Actually, since the interactive HTML plots are embedded INTO the report template (read back and injected), we should use `include_plotlyjs=False` for ALL modes when generating standalone plot HTML files. The plotly.js loading is handled by the report template's `<head>`. Use `full_html=False` to generate just the div+script for the plot, not a full HTML document.

  Change:
  ```python
  fig_box.write_html(boxplot_filename_interactive, include_plotlyjs=False, full_html=False)
  ```
  Same for fig_scatter.

- Only generate PNGs when static_report=True:
  ```python
  boxplot_filename_png = None
  scatter_filename_png = None
  if static_report:
      import kaleido
      kaleido.start_sync_server()

      boxplot_filename_png = os.path.join(plots_dir, PLOT_SAMPLE_REPORT["output_box_plot_filename"])
      fig_box.write_image(boxplot_filename_png)

      scatter_filename_png = os.path.join(plots_dir, PLOT_SAMPLE_REPORT["output_scatter_plot_filename"])
      fig_scatter.write_image(scatter_filename_png)
  ```

**C. Update generate_report() for conditional non-interactive report:**

Update signature to accept static_report and plotly_mode:
```python
def generate_report(
    summary_df: pd.DataFrame,
    output_folder: str,
    ...existing params...,
    boxplot_filename_png: str | None = None,
    scatter_filename_png: str | None = None,
    ...
    static_report: bool = False,
    plotly_mode: str = "directory",
) -> None:
```

Changes inside generate_report():
- The interactive HTML report is ALWAYS generated
- Pass `plotly_mode` and a `plotly_version` to the template render context
- To get the plotly version: `import plotly; plotly_version = plotly.__version__` (or extract the bundled plotly.js version)
- For the non-interactive HTML report: only generate when `static_report=True`
- When static_report=False, skip reading PNG files and skip rendering non-interactive report

**D. Plotly.js asset management for directory mode:**

Add a helper function to manage the shared plotly.min.js:
```python
def _ensure_plotly_assets(output_folder: str) -> str:
    """Copy plotly.min.js to output/assets/ if not already present. Returns relative path from report HTML to plotly.min.js."""
    import plotly

    # Find the bundled plotly.min.js
    plotly_dir = os.path.dirname(plotly.__file__)
    plotly_js_source = os.path.join(plotly_dir, "package_data", "plotly.min.js")

    # Determine the output assets directory
    # output_folder is like output/sample/plasmid/
    # We want output/assets/plotly.min.js (two levels up from sample/plasmid/)
    # Walk up to find the root output directory
    assets_dir = os.path.join(_find_output_root(output_folder), "assets")
    os.makedirs(assets_dir, exist_ok=True)

    dest = os.path.join(assets_dir, "plotly.min.js")
    if not os.path.exists(dest):
        import shutil
        shutil.copy2(plotly_js_source, dest)
        logging.info(f"Copied plotly.min.js to {dest}")

    # Return relative path from output_folder to assets/plotly.min.js
    return os.path.relpath(dest, output_folder)


def _find_output_root(output_folder: str) -> str:
    """Find the root output directory (the one that contains sample subdirs).

    output_folder is typically output/sample_name/plasmid_name/
    The root is output/ (two levels up).
    However, for standalone report command, output_folder might be the root itself.
    Use heuristic: walk up until we find a directory that doesn't look like a sample subdir.

    Simple approach: go up 2 levels if path has at least 2 components after a base.
    """
    # Simple heuristic: if output_folder has the pattern .../X/Y/ where X and Y exist,
    # assume root is ../ two levels up. Otherwise, use output_folder itself.
    parent = os.path.dirname(output_folder.rstrip(os.sep))
    grandparent = os.path.dirname(parent)
    if grandparent and os.path.isdir(grandparent):
        return grandparent
    return output_folder
```

IMPORTANT: If this heuristic is too fragile, a simpler approach: accept an explicit `output_root` parameter (the top-level output directory) and put assets/ there. The pipeline knows the root — it can pass it. For the standalone `report` command, use the output_folder itself as root.

Actually, the simplest reliable approach: add an `output_root` parameter (defaulting to None). When called from run_pipeline, pass the top-level `output_folder`. When called standalone (report subcommand), use the output_folder. Then:
```python
def _ensure_plotly_assets(output_root: str) -> None:
    """Copy plotly.min.js to {output_root}/assets/."""
```

And in the template, compute the relative path based on the nesting level.

Actually, let's keep it simple per the CONTEXT decisions: the assets go in `output/assets/`. The pipeline already knows the output root. Add `output_root: str | None = None` to `main()`. If None, use output_folder as root.

**E. Update main() signature:**

```python
def main(
    reads_assignment_file: str,
    summary_file: str,
    output_folder: str,
    threshold: float = DEFAULT_THRESHOLD,
    unclear: dict[str, float] = UNCLEAR_RANGE,
    human_fasta: str = "None",
    plasmid_gb: str = "None",
    sequencing_file: str = "None",
    command_line: str = "",
    static_report: bool = False,
    plotly_mode: str = "directory",
    output_root: str | None = None,
) -> None:
```

Pass static_report and plotly_mode through to generate_plots() and generate_report().
For directory mode, call `_ensure_plotly_assets()` with the appropriate root directory.
Compute the relative path from `output_folder` to the assets/plotly.min.js and pass it to the template.

**F. Update the __main__ block:**

Add --static-report and --plotly-mode flags to the standalone argparse at the bottom of the file, and pass them to main().

**Key anti-patterns to avoid:**
- Do NOT use `include_plotlyjs='directory'` (Plotly's built-in) — it copies plotly.min.js to each plot directory. Instead, manage the shared assets/ directory manually.
- Do NOT import kaleido at module level — only inside the `if static_report:` block.
- Do NOT use `type=bool` for argparse flags.
- Do NOT call `kaleido.start_sync_server()` without a subsequent `write_image()` — only call it when PNGs will actually be generated.
  </action>
  <verify>
Run `make lint` — no ruff errors.
Run `make typecheck` — no new mypy errors (existing test file may need updates, note them).
Run `make test-fast` — existing tests should still pass (they test load_data, downsample_data, extract_verdict which don't change behavior).
Run `python -c "from plasmicheck.scripts.generate_report import main; import inspect; print(inspect.signature(main))"` — confirm new parameters.
  </verify>
  <done>
generate_report.py has lazy imports (pandas, plotly, jinja2 at function level), conditional PNG export gated behind static_report flag, plotly.js inclusion mode support, and Kaleido start_sync_server() optimization. Default behavior generates only interactive HTML.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update report_template.html for plotly.js mode support</name>
  <files>plasmicheck/templates/report_template.html</files>
  <action>
Update the Jinja2 template to handle plotly.js loading based on the plotly_mode variable.

The current template simply renders `{{ box_plot|safe }}` and `{{ scatter_plot|safe }}` which were previously full HTML documents (from write_html with include_plotlyjs=True). Now the plots are div-only fragments (from write_html with include_plotlyjs=False, full_html=False), so the template must load plotly.js itself.

Replace the current `<head>` section with plotly.js mode-aware loading:

```html
<head>
    <meta charset="UTF-8">
    <title>plasmicheck Report</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">

    {% if plotly_mode == 'cdn' %}
        <script src="https://cdn.plot.ly/plotly-{{ plotly_version }}.min.js"></script>
    {% elif plotly_mode == 'directory' %}
        <script src="{{ plotly_js_path }}"></script>
        <script>
        if (typeof Plotly === 'undefined') {
            document.write('<script src="https://cdn.plot.ly/plotly-{{ plotly_version }}.min.js"><\/script>');
        }
        </script>
    {% elif plotly_mode == 'embedded' %}
        {# For embedded mode, plots include plotly.js themselves via include_plotlyjs=True #}
        {# But since we use full_html=False, we need to embed it here #}
        {{ plotly_js_inline|safe }}
    {% endif %}

    <style>
        body { margin: 20px; }
        h1, h2, h3 { text-align: center; margin-top: 20px; }
        .container { margin-top: 20px; }
        .table { margin-top: 20px; width: 50%; margin-left: auto; margin-right: auto; }
        .plot { margin: 20px auto; display: block; width: 1000px; max-width: 100%; }
        .verdict { text-align: center; font-size: 1.5em; margin-top: 30px; }
        .verdict span { font-weight: bold; }
        .details { text-align: center; margin-top: 10px; font-size: 0.9em; }
        .logo { text-align: center; margin-bottom: 30px; }
        .downsample-note { text-align: center; font-size: 1em; color: red; margin-top: 20px; }
    </style>
</head>
```

For the embedded mode's `plotly_js_inline`, in generate_report.py, read the plotly.min.js file content and wrap it in a `<script>` tag, then pass it as a template variable. Only do this for embedded mode to avoid bloating the template context for other modes.

The body section mostly stays the same, but update the plot rendering:

For interactive mode (`{% if interactive %}`):
```html
<div class="plot">
    {% if interactive %}
        {{ box_plot|safe }}
    {% else %}
        <img src="{{ box_plot }}" alt="Box Plot">
    {% endif %}
</div>
```
This stays the same — box_plot is now a div+script fragment (not full HTML), and plotly.js is loaded in head.

For the `interactive` template variable: this controls interactive vs non-interactive (PNG-based) reports. Keep this logic. The interactive report uses plot divs; the non-interactive uses base64 PNG images. The non-interactive report is only generated when static_report=True.

Make sure the template renders correctly when `plotly_mode` is not passed (backwards compatibility for any direct template usage): add defaults:
```html
{% if plotly_mode is not defined %}{% set plotly_mode = 'embedded' %}{% endif %}
```

This ensures backwards compatibility if the template is rendered without the new variables.
  </action>
  <verify>
Read the updated template and verify:
1. Jinja2 conditionals for plotly_mode are syntactically correct
2. CDN fallback pattern present for directory mode
3. Embedded mode has script injection point
4. CSS styles preserved from original
5. Plot rendering sections unchanged (interactive/non-interactive conditionals)

Run `make lint` (templates aren't linted by ruff, but verify no Python changes broke anything).
Run `make test-fast` to confirm no regressions.
  </verify>
  <done>
report_template.html loads plotly.js conditionally based on plotly_mode: cdn mode uses CDN script tag, directory mode uses local path with CDN fallback, embedded mode uses inline plotly.js. Interactive/non-interactive plot rendering preserved.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from plasmicheck.scripts.generate_report import main"` succeeds (no import-time errors from lazy imports)
2. `make lint` passes
3. `make typecheck` passes (or only has expected errors from generate_summary_reports.py not yet updated)
4. `make test-fast` passes
5. generate_report.main() signature includes static_report, plotly_mode, output_root parameters
6. report_template.html contains plotly_mode conditionals and CDN fallback
</verification>

<success_criteria>
- REPT-01 (partial): generate_report.py default path skips PNG generation
- REPT-02 (partial): generate_report.py generates PNGs when static_report=True
- REPT-03 (partial): generate_report.py supports directory mode with shared plotly.min.js
- REPT-04 (partial): generate_report.py supports cdn/directory/embedded modes
- REPT-05 (partial): Kaleido start_sync_server() called before write_image when static_report=True
- REPT-06 (partial): pandas, plotly, jinja2 imported at function level in generate_report.py
- Template correctly handles all three plotly.js modes
</success_criteria>

<output>
After completion, create `.planning/phases/05-report-optimization/05-02-SUMMARY.md`
</output>
