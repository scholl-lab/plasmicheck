---
phase: 06-alignment-optimization
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - plasmicheck/cli.py
  - plasmicheck/scripts/run_pipeline.py
  - tests/test_thread_cli.py
autonomous: true

must_haves:
  truths:
    - "User can pass --threads N to pipeline subcommand"
    - "--threads overrides auto-detection (logged as 'CLI --threads=N')"
    - "Without --threads, pipeline auto-detects CPUs and logs source"
    - "Thread count and detection source are always logged at pipeline start"
    - "Minimap2 and samtools thread counts are logged before alignment"
    - "Alignments run sequentially with full thread allocation to each"
    - "samtools sort memory value comes from config.json"
  artifacts:
    - path: "plasmicheck/cli.py"
      provides: "--threads argument on pipeline subcommand"
      contains: "--threads"
    - path: "plasmicheck/scripts/run_pipeline.py"
      provides: "Thread detection, allocation, and logging at pipeline start; thread params passed to align_reads"
    - path: "tests/test_thread_cli.py"
      provides: "Tests for CLI --threads wiring and pipeline thread integration"
  key_links:
    - from: "plasmicheck/cli.py"
      to: "plasmicheck/scripts/run_pipeline.py"
      via: "args.threads passed to run_pipeline(threads=...)"
      pattern: "threads=args\\.threads"
    - from: "plasmicheck/scripts/run_pipeline.py"
      to: "plasmicheck/thread_config.py"
      via: "import detect_cpu_count, allocate_threads"
      pattern: "from.*thread_config import"
    - from: "plasmicheck/scripts/run_pipeline.py"
      to: "plasmicheck/scripts/align_reads.py"
      via: "minimap2_threads and samtools_threads passed to align_reads()"
      pattern: "align_reads.*minimap2_threads.*samtools_threads"
---

<objective>
Wire the --threads CLI flag through the pipeline and integrate thread detection/allocation into the alignment execution flow.

Purpose: Completes the alignment optimization by connecting the building blocks from Plan 01 (thread_config.py, parameterized align_reads) to the user-facing CLI and pipeline orchestration. After this plan, users get automatic CPU detection with optional --threads override, transparent logging, and optimized samtools sort memory.

Output: Updated `cli.py` with --threads flag, updated `run_pipeline.py` with thread detection/allocation/logging, integration tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-alignment-optimization/06-CONTEXT.md
@.planning/phases/06-alignment-optimization/06-RESEARCH.md
@.planning/phases/06-alignment-optimization/06-01-SUMMARY.md
@plasmicheck/cli.py
@plasmicheck/scripts/run_pipeline.py
@plasmicheck/thread_config.py
@plasmicheck/scripts/align_reads.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --threads CLI flag and wire through pipeline</name>
  <files>plasmicheck/cli.py, plasmicheck/scripts/run_pipeline.py</files>
  <action>
**In `plasmicheck/cli.py`:**

1. Add `--threads` argument to the `parser_pipeline` subcommand (after the existing `--no_progress` argument):
   ```python
   parser_pipeline.add_argument(
       "--threads",
       type=int,
       default=None,
       help="Total thread count for alignment (default: auto-detect via SLURM/cgroup/os)",
   )
   ```

2. In the `elif args.command == "pipeline":` block, pass `threads=args.threads` to `run_pipeline()`:
   ```python
   run_pipeline(
       ...existing args...,
       threads=args.threads,
   )
   ```

**In `plasmicheck/scripts/run_pipeline.py`:**

1. Add import at top of file:
   ```python
   from plasmicheck.thread_config import allocate_threads, detect_cpu_count
   ```

2. Add `threads: int | None = None` parameter to `run_pipeline()` function signature (after `plotly_mode`).

3. After the `logging.info("Starting the pipeline...")` line and input parameter logging, add thread detection and logging block:
   ```python
   # Thread detection and allocation
   if threads is not None:
       total_threads = threads
       thread_source = f"CLI --threads={threads}"
   else:
       total_threads, thread_source = detect_cpu_count()

   mm2_threads, sam_threads = allocate_threads(total_threads)
   sort_memory = get_config().get("alignment", {}).get("samtools_sort_memory", "2G")

   logging.info(f"Using {total_threads} threads ({thread_source})")
   logging.info(f"  minimap2: {mm2_threads} threads, samtools: {sam_threads} threads")
   logging.info(f"  samtools sort memory: {sort_memory} per thread")
   ```

   Note: `get_config` is not currently imported in run_pipeline.py. Import it:
   ```python
   from plasmicheck.config import get_config
   ```

4. Update the two `align_reads()` calls (lines ~559-560) to pass thread and memory parameters:
   ```python
   align_reads(
       plasmid_index, sequencing_file, plasmid_bam, "plasmid", fastq2,
       minimap2_threads=mm2_threads,
       samtools_threads=sam_threads,
       samtools_sort_memory=sort_memory,
   )
   align_reads(
       spliced_index, sequencing_file, spliced_human_bam, "human", fastq2,
       minimap2_threads=mm2_threads,
       samtools_threads=sam_threads,
       samtools_sort_memory=sort_memory,
   )
   ```

5. Also update the `if __name__ == "__main__"` block at the bottom of run_pipeline.py:
   - Add `--threads` argument to the argparse parser (same as cli.py definition)
   - Pass `threads=args.threads` in the run_pipeline() call

IMPORTANT: Keep alignments SEQUENTIAL (do NOT add ThreadPoolExecutor or concurrent execution). The user explicitly decided sequential execution to avoid memory pressure. The speedup comes from proper thread allocation, not concurrency.
  </action>
  <verify>
Run `plasmicheck pipeline --help` and confirm --threads flag appears in output. Run `make typecheck` -- no mypy errors. Run `make lint` -- no ruff issues.
  </verify>
  <done>
--threads flag visible in `plasmicheck pipeline --help`. run_pipeline() detects threads, logs source, passes to align_reads(). Alignments remain sequential.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for thread CLI and pipeline wiring</name>
  <files>tests/test_thread_cli.py</files>
  <action>
Create `tests/test_thread_cli.py` with tests covering the CLI and pipeline integration:

1. **Test CLI --threads flag is parsed correctly:**
   - Use subprocess or argparse to verify `plasmicheck pipeline --help` includes `--threads`
   - Test that `--threads 8` is parsed to `args.threads == 8`
   - Test that omitting `--threads` results in `args.threads is None`

2. **Test run_pipeline thread detection with --threads override:**
   - Mock `align_reads` to capture its arguments (use unittest.mock.patch on `plasmicheck.scripts.run_pipeline.align_reads`)
   - Mock other pipeline steps (convert, create_indexes, spliced_alignment, etc.) to no-op
   - Call run_pipeline with `threads=8` and verify align_reads was called with minimap2_threads and samtools_threads matching allocate_threads(8) output
   - Verify align_reads was called with samtools_sort_memory from config

3. **Test run_pipeline thread detection without --threads:**
   - Mock `detect_cpu_count` to return (4, "test-mock")
   - Mock pipeline steps as above
   - Call run_pipeline with `threads=None`
   - Verify detect_cpu_count was called
   - Verify align_reads received threads matching allocate_threads(4)

4. **Test thread logging output:**
   - Use `caplog` fixture to capture logging output
   - Call run_pipeline with `threads=8` (mocking pipeline steps)
   - Assert log contains "Using 8 threads (CLI --threads=8)"
   - Assert log contains "minimap2:" and "samtools:"

Mark all tests with @pytest.mark.unit. Use monkeypatch/mock for all external calls so tests don't require minimap2/samtools or real data files.

For tests that call run_pipeline(), you'll need to mock many dependencies. Consider creating a helper fixture that patches all the heavy pipeline steps (convert, create_indexes, spliced_alignment, extract_human_reference, extract_plasmid_cdna_positions, compare_alignments, generate_report, quality_control, write_md5sum) to no-op. The key thing to verify is that align_reads receives the correct thread parameters.

Alternatively, test at a lower level: test that run_pipeline constructs the correct thread allocation and would pass it to align_reads, without actually calling the full pipeline. You can patch just the imports used inside run_pipeline.
  </action>
  <verify>
Run `make test-fast` -- all new and existing tests pass. Run `make typecheck` -- no mypy errors. Run `make lint` -- no ruff issues.
  </verify>
  <done>
Tests verify: --threads CLI flag parsed correctly, thread values passed to align_reads, detection fallback works, logging shows thread source. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `make test-fast` -- all tests pass (existing + new)
2. `make typecheck` -- no mypy errors
3. `make lint` -- no ruff issues
4. `plasmicheck pipeline --help` shows --threads flag with correct help text
5. Check logging output: `plasmicheck pipeline --help 2>&1 | grep -i thread` confirms flag presence
</verification>

<success_criteria>
- `--threads N` flag available on pipeline subcommand only
- Pipeline logs thread count and detection source at startup (always, not just verbose)
- Pipeline logs minimap2/samtools thread split
- align_reads() receives explicit thread counts from pipeline (not relying on globals)
- Alignments remain sequential (no concurrent execution)
- samtools sort memory loaded from config.json
- All tests pass, no type errors, no lint issues
</success_criteria>

<output>
After completion, create `.planning/phases/06-alignment-optimization/06-02-SUMMARY.md`
</output>
