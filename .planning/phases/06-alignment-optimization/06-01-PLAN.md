---
phase: 06-alignment-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - plasmicheck/thread_config.py
  - plasmicheck/scripts/align_reads.py
  - plasmicheck/config.json
  - tests/test_thread_config.py
autonomous: true

must_haves:
  truths:
    - "detect_cpu_count() returns correct CPU count from SLURM env var when set"
    - "detect_cpu_count() reads cgroup v2 cpu.max when no SLURM var present"
    - "detect_cpu_count() reads cgroup v1 quota/period when no v2 available"
    - "detect_cpu_count() falls back to os.cpu_count() on bare metal"
    - "detect_cpu_count() returns (4, 'fallback') when all detection fails"
    - "allocate_threads() enforces min 2, max 16 bounds"
    - "allocate_threads() gives ~80% threads to minimap2, rest to samtools (max 4)"
    - "align_reads() uses passed thread counts instead of module-level globals"
    - "samtools sort commands include -m flag with configurable memory"
  artifacts:
    - path: "plasmicheck/thread_config.py"
      provides: "CPU detection chain and thread allocation logic"
      exports: ["detect_cpu_count", "allocate_threads"]
    - path: "plasmicheck/scripts/align_reads.py"
      provides: "Parameterized alignment with thread and memory args"
    - path: "plasmicheck/config.json"
      provides: "samtools_sort_memory default setting"
      contains: "samtools_sort_memory"
    - path: "tests/test_thread_config.py"
      provides: "Unit tests for detection chain and allocation"
  key_links:
    - from: "plasmicheck/thread_config.py"
      to: "plasmicheck/scripts/align_reads.py"
      via: "thread counts passed as parameters"
      pattern: "minimap2_threads.*samtools_threads"
    - from: "plasmicheck/config.json"
      to: "plasmicheck/scripts/align_reads.py"
      via: "samtools_sort_memory config value"
      pattern: "samtools_sort_memory"
---

<objective>
Create the thread detection and allocation module, update align_reads to accept thread parameters and samtools sort memory flag, and add unit tests.

Purpose: Provides the building blocks for alignment optimization -- CPU auto-detection across Docker/SLURM/bare-metal environments, thread allocation between minimap2 and samtools, and parameterized alignment commands. Plan 02 wires these into the CLI and pipeline.

Output: New `thread_config.py` module, updated `align_reads.py`, updated `config.json`, comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-alignment-optimization/06-CONTEXT.md
@.planning/phases/06-alignment-optimization/06-RESEARCH.md
@plasmicheck/scripts/align_reads.py
@plasmicheck/config.json
@plasmicheck/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create thread_config.py with detect_cpu_count() and allocate_threads()</name>
  <files>plasmicheck/thread_config.py, tests/test_thread_config.py</files>
  <action>
Create `plasmicheck/thread_config.py` with two public functions:

1. `detect_cpu_count() -> tuple[int, str]`:
   - Detection chain priority: SLURM_CPUS_PER_TASK env var > cgroup v2 (/sys/fs/cgroup/cpu.max) > cgroup v1 (/sys/fs/cgroup/cpu/cpu.cfs_quota_us + cpu.cfs_period_us) > os.cpu_count() > fallback(4)
   - Returns (cpu_count, source_description) tuple
   - source_description is human-readable for logging (e.g., "SLURM_CPUS_PER_TASK", "cgroup v2", "cgroup v1", "os.cpu_count()", "fallback")
   - Use pathlib.Path for cgroup file reads
   - Wrap each detection step in try/except (ValueError, IOError, OSError) so failures fall through silently
   - Log a warning (via logging.warning) ONLY on final fallback
   - For cgroup v2: parse "quota period" from cpu.max, skip if quota is "max" (unlimited)
   - For cgroup v1: skip if quota is -1 (unlimited)
   - Use `from __future__ import annotations` for type hints

2. `allocate_threads(total_cpus: int) -> tuple[int, int]`:
   - Apply bounds: min 2, max 16 (clamp total_cpus to this range)
   - Allocate ~80% to minimap2 (int(total * 0.8)), at least 2
   - Allocate remainder to samtools, at least 2, max 4
   - If minimap2 + samtools > total after min enforcement, reduce samtools to max(2, total - minimap2)
   - Returns (minimap2_threads, samtools_threads)

Create `tests/test_thread_config.py` with unit tests:
- Test detect_cpu_count with SLURM env var set (monkeypatch os.environ)
- Test detect_cpu_count with SLURM unset, mock cgroup v2 file (use tmp_path to create fake /sys/fs/cgroup/cpu.max, monkeypatch the Path used)
- Test detect_cpu_count with all detection failing (monkeypatch os.cpu_count to return None, no env vars, no cgroup files)
- Test allocate_threads with various inputs: 2 (minimum), 4, 8, 16, 32 (capped to 16), 1 (clamped to 2)
- Verify minimap2 always >= 2, samtools always >= 2 and <= 4
- Verify minimap2 + samtools <= total (after clamping)
- Mark all tests with @pytest.mark.unit

Use monkeypatch or unittest.mock.patch for os.environ and file system mocking. Do NOT actually read system cgroup files in tests.
  </action>
  <verify>
Run `make test-fast` and confirm new tests pass. Run `make typecheck` and confirm no new mypy errors. Run `make lint` and confirm no ruff issues.
  </verify>
  <done>
detect_cpu_count() correctly detects SLURM, cgroup v2, cgroup v1, os.cpu_count(), and fallback. allocate_threads() respects min/max bounds and 80/20 split. All unit tests pass. No mypy or lint errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update align_reads.py signature and config.json for thread/memory parameters</name>
  <files>plasmicheck/scripts/align_reads.py, plasmicheck/config.json</files>
  <action>
Update `plasmicheck/config.json`:
- Add `"samtools_sort_memory": "2G"` to the existing `"alignment"` object (alongside minimap2_threads, samtools_threads, fasta_extensions)

Update `plasmicheck/scripts/align_reads.py`:

1. Change the `align_reads()` function signature to accept three new optional parameters with defaults from config:
   ```python
   def align_reads(
       reference_index: str,
       input_file: str,
       output_bam: str,
       alignment_type: str,
       fastq2: str | None = None,
       minimap2_threads: int | None = None,
       samtools_threads: int | None = None,
       samtools_sort_memory: str | None = None,
   ) -> None:
   ```

2. Inside the function body (NOT at module level), resolve defaults from config when None:
   ```python
   cfg = get_config()
   if minimap2_threads is None:
       minimap2_threads = cfg["alignment"]["minimap2_threads"]
   if samtools_threads is None:
       samtools_threads = cfg["alignment"]["samtools_threads"]
   if samtools_sort_memory is None:
       samtools_sort_memory = cfg["alignment"].get("samtools_sort_memory", "2G")
   ```

3. Remove the module-level `MINIMAP2_THREADS` and `SAMTOOLS_THREADS` globals (lines 9-11).

4. Update ALL command strings to use the local variables instead of globals, AND add `-m {samtools_sort_memory}` to every `samtools sort` command. There are 3 command construction branches (BAM input, paired FASTQ, single FASTQ). Each must have:
   - `minimap2 -t {minimap2_threads}` (already uses variable, just needs renaming from MINIMAP2_THREADS)
   - `samtools view -@ {samtools_threads}` (same)
   - `samtools sort -@ {samtools_threads} -m {samtools_sort_memory} -o {output_bam}` (add -m flag)

5. Update the logging.info at the start of the function to include thread counts:
   ```python
   logging.info(
       f"Starting alignment of {input_file} against {reference_index} as {alignment_type} "
       f"(minimap2: {minimap2_threads}t, samtools: {samtools_threads}t, sort mem: {samtools_sort_memory})"
   )
   ```

6. Update the `if __name__ == "__main__"` block: the argparse-based standalone invocation should still work by passing no thread args (defaults from config apply).

IMPORTANT: Keep backward compatibility -- existing callers that don't pass thread args get config defaults, same as before.
  </action>
  <verify>
Run `make typecheck` -- no new mypy errors. Run `make lint` -- no ruff issues. Run `make test-fast` -- all existing tests pass (backward compatibility). Verify config.json is valid JSON with `python -c "import json; json.load(open('plasmicheck/config.json'))"`.
  </verify>
  <done>
align_reads() accepts minimap2_threads, samtools_threads, samtools_sort_memory as optional parameters. Module-level thread globals removed. All samtools sort commands include -m flag. config.json has samtools_sort_memory: "2G". All existing tests pass unchanged.
  </done>
</task>

</tasks>

<verification>
1. `make test-fast` -- all tests pass including new thread_config tests
2. `make typecheck` -- no mypy errors
3. `make lint` -- no ruff issues
4. `python -c "from plasmicheck.thread_config import detect_cpu_count, allocate_threads; print(detect_cpu_count()); print(allocate_threads(8))"` -- imports and runs without error
5. `python -c "from plasmicheck.scripts.align_reads import align_reads"` -- imports without error (no module-level config issues)
</verification>

<success_criteria>
- detect_cpu_count() returns correct values for SLURM, cgroup v2, cgroup v1, os.cpu_count(), and fallback scenarios (proven by unit tests)
- allocate_threads() respects min 2, max 16, 80/20 split (proven by unit tests)
- align_reads() accepts thread/memory params, defaults to config when not provided
- samtools sort -m 2G present in all alignment commands
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/06-alignment-optimization/06-01-SUMMARY.md`
</output>
