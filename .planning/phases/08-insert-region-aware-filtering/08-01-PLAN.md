---
phase: 08-insert-region-aware-filtering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - plasmicheck/scripts/compare_alignments.py
  - plasmicheck/config.json
  - plasmicheck/config.py
  - plasmicheck/scripts/run_pipeline.py
  - plasmicheck/scripts/plotting/colors.py
  - tests/test_compare_alignments.py
  - tests/conftest.py
autonomous: true

must_haves:
  truths:
    - "Reads mapping only to backbone (outside insert region) are classified as Backbone_Only"
    - "Reads with score difference below score_margin are classified as Ambiguous"
    - "Backbone_Only and Ambiguous reads are excluded from contamination ratio when filter_backbone_only=true"
    - "Setting filter_backbone_only=false restores pre-v0.33.0 behavior (all existing tests pass unmodified)"
    - "Missing or malformed cDNA_positions.txt causes graceful fallback with warning, not crash"
    - "Comparison TSV always includes Backbone_Only and Ambiguous in AssignedTo column values"
    - "summary.tsv always includes Backbone_Only and Ambiguous count rows"
  artifacts:
    - path: "plasmicheck/scripts/compare_alignments.py"
      provides: "Insert-region-aware filtering with read_overlaps_insert(), extended _assign(), updated _streaming_compare()"
      contains: "read_overlaps_insert"
    - path: "plasmicheck/config.json"
      provides: "filter_backbone_only and score_margin configuration entries"
      contains: "filter_backbone_only"
    - path: "plasmicheck/scripts/run_pipeline.py"
      provides: "Pipeline wiring -- no change needed since compare_alignments() already reads cDNA_positions.txt internally"
    - path: "tests/test_compare_alignments.py"
      provides: "Tests for backbone classification, score margin, backward compat, graceful fallback"
      min_lines: 300
  key_links:
    - from: "plasmicheck/scripts/compare_alignments.py"
      to: "plasmicheck/config.json"
      via: "get_config() loading filter_backbone_only and score_margin"
      pattern: "filter_backbone_only|score_margin"
    - from: "plasmicheck/scripts/compare_alignments.py:_streaming_compare"
      to: "plasmicheck/scripts/compare_alignments.py:read_overlaps_insert"
      via: "Calling read_overlaps_insert for plasmid-only reads"
      pattern: "read_overlaps_insert"
    - from: "plasmicheck/scripts/compare_alignments.py:compare_alignments"
      to: "plasmicheck/scripts/compare_alignments.py:_streaming_compare"
      via: "Passing insert_region to _streaming_compare"
      pattern: "insert_region"
---

<objective>
Implement insert-region-aware read filtering in the core comparison logic, adding Backbone_Only and Ambiguous read categories, a backward-compatible config toggle, and optional score margin parameter.

Purpose: Eliminates false positive contamination calls for unrelated plasmids sharing only backbone sequence (issue #82). This is a scientific accuracy fix that all downstream Phase 9-11 features depend on.

Output: Modified compare_alignments.py with 5-category read classification, updated config.json with two new entries, comprehensive unit tests covering backbone classification, score margin, backward compat, and graceful fallback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-insert-region-aware-filtering/08-CONTEXT.md
@.planning/phases/08-insert-region-aware-filtering/08-RESEARCH.md
@plasmicheck/scripts/compare_alignments.py
@plasmicheck/config.json
@plasmicheck/config.py
@plasmicheck/scripts/run_pipeline.py
@plasmicheck/scripts/plotting/colors.py
@tests/test_compare_alignments.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Core filtering logic + config + pipeline wiring</name>
  <files>
    plasmicheck/scripts/compare_alignments.py
    plasmicheck/config.json
    plasmicheck/scripts/plotting/colors.py
  </files>
  <action>
  **1. Add config entries to `plasmicheck/config.json`:**
  Add two new top-level entries:
  ```json
  "filter_backbone_only": true,
  "score_margin": 0
  ```
  Also extend `plot_sample_report.colors` with:
  ```json
  "backbone_only": "lightgray",
  "ambiguous": "darkgray"
  ```

  **2. Update `plasmicheck/scripts/plotting/colors.py`:**
  Add Backbone_Only and Ambiguous to `ASSIGNMENT_COLORS`:
  ```python
  ASSIGNMENT_COLORS: dict[str, str] = {
      "Plasmid": "#636EFA",
      "Human": "#EF553B",
      "Tied": "#00CC96",
      "Backbone_Only": "#D3D3D3",  # lightgray
      "Ambiguous": "#A9A9A9",      # darkgray
  }
  ```

  **3. Update `plasmicheck/scripts/compare_alignments.py`:**

  a) Load new config values at module level (alongside existing config loads):
  ```python
  FILTER_BACKBONE_ONLY: bool = _cfg.get("filter_backbone_only", True)
  SCORE_MARGIN: int = _cfg.get("score_margin", 0)
  ```

  b) Add `read_overlaps_insert()` function (after `parse_insert_region`, before `calculate_coverage_outside_insert`):
  ```python
  def read_overlaps_insert(read: Any, insert_region: tuple[int, int]) -> bool:
      """Check if read alignment overlaps the insert region.

      Uses pysam half-open interval convention:
      - read.reference_start: 0-based, inclusive
      - read.reference_end: 0-based, exclusive

      insert_region uses inclusive boundaries on both ends (from cDNA_positions.txt).
      """
      if read.is_unmapped:
          return False
      read_start = read.reference_start
      read_end = read.reference_end
      if read_start is None or read_end is None:
          return False
      # No overlap: read ends before insert starts, or read starts after insert ends
      if read_end <= insert_region[0] or read_start > insert_region[1]:
          return False
      return True
  ```
  This follows the EXACT pattern from `calculate_coverage_outside_insert()` lines 87-97, using the same boundary logic. The critical detail: `read_end <= insert_region[0]` (not `<`) because `reference_end` is exclusive.

  c) Modify `_assign()` to accept optional parameters and handle new categories. **Replace the existing `_assign` function** with:
  ```python
  def _assign(
      plasmid_score: int,
      human_score: int,
      *,
      plasmid_read: Any | None = None,
      insert_region: tuple[int, int] | None = None,
      score_margin: int = 0,
  ) -> str:
      """Assign read to category with optional backbone and margin filtering.

      Order of checks:
      1. Score margin (if enabled and scores differ) -> Ambiguous
      2. Exact tie -> Tied
      3. Plasmid wins + insert_region available -> check overlap -> Plasmid or Backbone_Only
      4. Plasmid wins + no insert_region -> Plasmid (fallback)
      5. Human wins -> Human
      """
      # Score margin check first (if enabled)
      if score_margin > 0:
          score_diff = abs(plasmid_score - human_score)
          if 0 < score_diff < score_margin:
              return "Ambiguous"

      # Exact tie
      if plasmid_score == human_score:
          return "Tied"

      # Plasmid wins
      if plasmid_score > human_score:
          if insert_region is not None and plasmid_read is not None:
              if read_overlaps_insert(plasmid_read, insert_region):
                  return "Plasmid"
              else:
                  return "Backbone_Only"
          return "Plasmid"

      # Human wins
      return "Human"
  ```
  IMPORTANT: `score_margin=0` means disabled (not "allow 0 difference"). When `score_margin=0`, the `0 < score_diff` condition prevents any reads from being classified as Ambiguous. Tied reads (exact match) remain "Tied" and are NEVER classified as "Ambiguous".

  d) Modify `_streaming_compare()` signature to accept `insert_region` and `score_margin`:
  ```python
  def _streaming_compare(
      plasmid_ns_bam: str,
      human_ns_bam: str,
      outfile: IO[str],
      *,
      insert_region: tuple[int, int] | None = None,
      score_margin: int = 0,
  ) -> dict[str, int]:
  ```
  Initialize `assigned_counts` with all 5 categories:
  ```python
  assigned_counts: dict[str, int] = {
      "Plasmid": 0, "Human": 0, "Tied": 0,
      "Backbone_Only": 0, "Ambiguous": 0,
  }
  ```
  Update all three branches (both-reads, plasmid-only, human-only) to call `_assign()` with the new keyword arguments:
  - Both-reads branch (line ~230): `assigned = _assign(ps, hs, plasmid_read=p_read, insert_region=insert_region, score_margin=score_margin)`
  - Plasmid-only branch (line ~242): `assigned = _assign(ps, 0, plasmid_read=p_read, insert_region=insert_region, score_margin=score_margin)`
  - Human-only branch (line ~252): `assigned = _assign(0, hs, score_margin=score_margin)` (no plasmid_read, no insert_region check needed for human-only)

  e) Modify `compare_alignments()` function:
  - Replace the hard `FileNotFoundError` for missing cDNA_positions.txt with a graceful fallback:
    ```python
    # Parse insert region with graceful fallback
    cdna_positions_file = os.path.join(os.path.dirname(output_basename), "cDNA_positions.txt")
    insert_region: tuple[int, int] | None = None
    try:
        insert_region = parse_insert_region(cdna_positions_file)
        logging.debug(f"INSERT_REGION extracted from {cdna_positions_file}: {insert_region}")
    except (FileNotFoundError, ValueError, IndexError) as e:
        logging.warning(
            f"Backbone filtering unavailable: {e}. "
            "Falling back to pre-v0.33.0 behavior (no insert-region filtering)."
        )
    ```
  - IMPORTANT: Keep the existing `calculate_coverage_outside_insert()` and `count_mismatches_near_insert_end()` calls, but wrap them so they only run when `insert_region` is not None:
    ```python
    coverage_outside_insert = 0.0
    mismatches_near_insert: dict[str, int] = {
        "with_mismatches_or_clipping": 0,
        "without_mismatches_or_clipping": 0,
    }
    if insert_region is not None:
        coverage_outside_insert = calculate_coverage_outside_insert(plasmid_bam, insert_region)
        logging.debug(f"Coverage outside INSERT_REGION: {coverage_outside_insert}")
        mismatches_near_insert = count_mismatches_near_insert_end(plasmid_bam, insert_region)
        logging.debug(f"Mismatches near INSERT_REGION: {mismatches_near_insert}")
    else:
        logging.warning("Skipping coverage/mismatch metrics (insert region unavailable).")
    ```
  - Pass `insert_region` and `SCORE_MARGIN` to `_streaming_compare()`:
    ```python
    assigned_counts = _streaming_compare(
        plasmid_ns, human_ns, outfile,
        insert_region=insert_region,
        score_margin=SCORE_MARGIN,
    )
    ```
  - Update ratio calculation to respect `FILTER_BACKBONE_ONLY`:
    ```python
    plasmid_count = assigned_counts["Plasmid"]
    human_count = assigned_counts["Human"]
    if FILTER_BACKBONE_ONLY:
        # Exclude Backbone_Only and Ambiguous from ratio (new v0.33.0 behavior)
        ratio = plasmid_count / human_count if human_count != 0 else float("inf")
    else:
        # Include all plasmid-favoring categories (pre-v0.33.0 behavior)
        effective_plasmid = plasmid_count + assigned_counts["Backbone_Only"] + assigned_counts["Ambiguous"]
        ratio = effective_plasmid / human_count if human_count != 0 else float("inf")
    ```
  - Update summary.tsv writing to always include Backbone_Only and Ambiguous rows:
    ```python
    with open(f"{output_basename}.summary.tsv", "w") as summary_file:
        summary_file.write("Category\tCount\n")
        for category, count in assigned_counts.items():
            summary_file.write(f"{category}\t{count}\n")
        summary_file.write(f"Verdict\t{verdict}\n")
        summary_file.write(f"Ratio\t{ratio}\n")
        summary_file.write(f"CoverageOutsideINSERT\t{coverage_outside_insert:.4f}\n")
        summary_file.write(f"MismatchesNearINSERT\t{mismatches_near_insert}\n")
    ```
    Since `assigned_counts` now always has all 5 keys, Backbone_Only and Ambiguous are always written.

  **4. Note on run_pipeline.py:**
  No changes needed to run_pipeline.py. The `compare_alignments()` function already reads cDNA_positions.txt from the output directory internally (line 267). The graceful fallback added above handles missing files. The pipeline orchestration remains unchanged.
  </action>
  <verify>
  Run: `make lint && make typecheck`
  Both must pass with no errors. Config.json must be valid JSON (python -c "import json; json.load(open('plasmicheck/config.json'))").
  </verify>
  <done>
  - compare_alignments.py contains `read_overlaps_insert()`, extended `_assign()` with 5 categories, updated `_streaming_compare()` with insert_region/score_margin parameters
  - config.json has `filter_backbone_only: true` and `score_margin: 0`
  - colors.py has Backbone_Only and Ambiguous entries
  - `compare_alignments()` gracefully handles missing cDNA_positions.txt
  - Ratio calculation respects FILTER_BACKBONE_ONLY toggle
  - summary.tsv always includes all 5 category rows
  - Lint and typecheck pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive unit tests</name>
  <files>
    tests/test_compare_alignments.py
    tests/conftest.py
  </files>
  <action>
  **1. Update `tests/conftest.py`:**

  a) Update `sample_summary_df` fixture to include Backbone_Only and Ambiguous rows:
  ```python
  @pytest.fixture
  def sample_summary_df() -> pd.DataFrame:
      return pd.DataFrame({
          "Category": [
              "Plasmid", "Human", "Tied", "Backbone_Only", "Ambiguous",
              "Verdict", "Ratio",
              "CoverageOutsideINSERT", "MismatchesNearINSERT",
          ],
          "Count": [
              100, 50, 10, 15, 5,
              "Sample is contaminated with plasmid DNA", 2.0,
              0.1234,
              "{'with_mismatches_or_clipping': 5, 'without_mismatches_or_clipping': 10}",
          ],
      })
  ```

  b) Add `sample_reads_assignment_df_extended` fixture that includes Backbone_Only and Ambiguous reads:
  ```python
  @pytest.fixture
  def sample_reads_assignment_df_extended() -> pd.DataFrame:
      return pd.DataFrame({
          "ReadID": ["read1", "read2", "read3", "read4", "read5", "read6", "read7"],
          "AssignedTo": ["Plasmid", "Human", "Tied", "Plasmid", "Human", "Backbone_Only", "Ambiguous"],
          "PlasmidScore": [70, 30, 50, 65, 20, 55, 42],
          "HumanScore": [30, 70, 50, 25, 60, 0, 40],
          "PlasmidCIGAR": ["100M", "50M50S", "75M25S", "100M", "30M70S", "100M", "80M20S"],
          "HumanCIGAR": ["50M50S", "100M", "75M25S", "30M70S", "100M", "NA", "90M10S"],
          "PlasmidMapQ": [60, 20, 40, 55, 10, 50, 45],
          "HumanMapQ": [20, 60, 40, 15, 55, 0, 35],
      })
  ```

  **2. Add comprehensive tests to `tests/test_compare_alignments.py`:**

  Update imports to include `read_overlaps_insert`:
  ```python
  from plasmicheck.scripts.compare_alignments import (
      _assign,
      _best_read,
      _streaming_compare,
      _write_assignment,
      calculate_alignment_score,
      parse_insert_region,
      read_overlaps_insert,
  )
  ```

  Add these test classes:

  a) **TestReadOverlapsInsert** (~10 tests):
  Test the `read_overlaps_insert()` function with mock_pysam_read fixture.
  - `test_read_entirely_within_insert`: read at (200, 400) with insert (100, 500) -> True
  - `test_read_entirely_outside_before`: read at (0, 50) with insert (100, 500) -> False (entirely before insert)
  - `test_read_entirely_outside_after`: read at (600, 700) with insert (100, 500) -> False (entirely after insert)
  - `test_read_overlaps_insert_start`: read at (50, 150) with insert (100, 500) -> True (partial overlap at start)
  - `test_read_overlaps_insert_end`: read at (450, 550) with insert (100, 500) -> True (partial overlap at end)
  - `test_read_exactly_at_insert_start_boundary`: read with reference_start=100, reference_end=200 with insert (100, 500) -> True (starts exactly at insert start)
  - `test_read_exactly_at_insert_end_boundary`: read with reference_start=400, reference_end=501 with insert (100, 500) -> True (reference_end=501 is exclusive, so last base aligns at 500 which IS in insert)
  - `test_read_ends_exactly_at_insert_start`: read with reference_end=100 with insert (100, 500) -> False (reference_end is exclusive, so last aligned base is 99, which is BEFORE insert)
  - `test_read_starts_exactly_after_insert_end`: read with reference_start=501 with insert (100, 500) -> False
  - `test_unmapped_read`: unmapped read -> False
  - `test_none_reference_positions`: read with reference_start=None -> False

  b) **TestAssignExtended** (~12 tests):
  Test the extended `_assign()` function with keyword arguments.
  - `test_plasmid_wins_no_filtering`: _assign(70, 30) -> "Plasmid" (backward compat, no insert_region)
  - `test_human_wins_no_filtering`: _assign(30, 70) -> "Human" (backward compat)
  - `test_tied_no_filtering`: _assign(50, 50) -> "Tied" (backward compat)
  - `test_plasmid_wins_overlaps_insert`: _assign(70, 30, plasmid_read=read_in_insert, insert_region=(100,500)) -> "Plasmid"
  - `test_plasmid_wins_outside_insert`: _assign(70, 0, plasmid_read=read_outside_insert, insert_region=(100,500)) -> "Backbone_Only"
  - `test_plasmid_only_read_outside_insert`: _assign(55, 0, plasmid_read=read_at_pos_0_50, insert_region=(100,500)) -> "Backbone_Only"
  - `test_plasmid_only_read_overlaps_insert`: _assign(55, 0, plasmid_read=read_at_pos_200_400, insert_region=(100,500)) -> "Plasmid"
  - `test_score_margin_makes_ambiguous`: _assign(52, 50, score_margin=5) -> "Ambiguous" (diff=2 < margin=5)
  - `test_score_margin_not_triggered_when_diff_exceeds`: _assign(70, 30, score_margin=5) -> "Plasmid" (diff=40 >= margin=5)
  - `test_score_margin_zero_disabled`: _assign(51, 50, score_margin=0) -> "Plasmid" (margin disabled, diff=1 enough)
  - `test_tied_not_ambiguous_with_margin`: _assign(50, 50, score_margin=10) -> "Tied" (exact tie is always Tied, never Ambiguous)
  - `test_human_not_affected_by_insert_region`: _assign(30, 70, plasmid_read=any_read, insert_region=(100,500)) -> "Human" (human wins regardless of region)

  c) **TestStreamingCompareWithFiltering** (~4 tests):
  Test `_streaming_compare()` with insert_region parameter using mocked iterators.
  - `test_plasmid_only_read_classified_backbone_only`: Mock plasmid-only read outside insert region -> Backbone_Only count = 1
  - `test_plasmid_only_read_classified_plasmid_when_overlaps_insert`: Mock plasmid-only read inside insert -> Plasmid count = 1
  - `test_no_insert_region_falls_back_to_old_behavior`: insert_region=None -> all plasmid-only reads classified as Plasmid (backward compat)
  - `test_score_margin_creates_ambiguous_in_stream`: Two reads with small score diff + score_margin > 0 -> Ambiguous count > 0

  d) **TestBackwardCompatibility** (~3 tests):
  Test that the existing TestAssign tests still pass (they call _assign with positional args only).
  - `test_existing_assign_api_unchanged`: _assign(70, 30) still returns "Plasmid" (positional args still work)
  - `test_existing_streaming_compare_api_unchanged`: _streaming_compare without insert_region works identically to before
  - `test_summary_tsv_always_has_five_categories`: After compare, summary.tsv contains rows for Plasmid, Human, Tied, Backbone_Only, Ambiguous

  All tests should use `@pytest.mark.unit` marker.
  Use `mock_pysam_read` fixture from conftest for creating reads with specific positions.
  Use `unittest.mock.patch` for _iter_reads_by_name in streaming compare tests.
  </action>
  <verify>
  Run: `make test-fast`
  All existing tests must still pass. New tests must pass. Target: ~15-20 new test functions.
  Also run: `make ci-check` to verify lint, format, typecheck, and tests all pass together.
  </verify>
  <done>
  - 15-20 new unit tests covering: read_overlaps_insert boundary cases, extended _assign with 5 categories, streaming compare with filtering, backward compatibility
  - All 170+ existing tests still pass
  - conftest.py updated with extended fixtures including Backbone_Only and Ambiguous
  - `make ci-check` passes cleanly
  </done>
</task>

</tasks>

<verification>
1. `make ci-check` passes (lint + format + typecheck + all tests)
2. `python -c "import json; json.load(open('plasmicheck/config.json'))"` succeeds
3. New config entries present: `grep -c 'filter_backbone_only\|score_margin' plasmicheck/config.json` returns 2
4. New function exists: `grep -c 'def read_overlaps_insert' plasmicheck/scripts/compare_alignments.py` returns 1
5. Five categories in assigned_counts: `grep 'Backbone_Only\|Ambiguous' plasmicheck/scripts/compare_alignments.py` has multiple matches
6. All new tests pass: `pytest tests/test_compare_alignments.py -v --tb=short`
</verification>

<success_criteria>
- FILT-01: Reads mapping only to backbone are classified as Backbone_Only and excluded from ratio
- FILT-02: Optional score_margin parameter classifies close-scoring reads as Ambiguous
- FILT-03: New categories (Backbone_Only, Ambiguous) tracked in comparison output (TSV + summary)
- FILT-04: filter_backbone_only config toggle; false restores pre-v0.33.0 behavior
- All existing 170+ tests pass without modification
- 15-20 new unit tests pass covering all new functionality
</success_criteria>

<output>
After completion, create `.planning/phases/08-insert-region-aware-filtering/08-01-SUMMARY.md`
</output>
