---
phase: 08-insert-region-aware-filtering
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - plasmicheck/scripts/generate_report.py
  - plasmicheck/templates/report_template.html
  - plasmicheck/scripts/plotting/matplotlib_backend.py
autonomous: true

must_haves:
  truths:
    - "Single-sample HTML report displays Backbone_Only and Ambiguous counts in the summary table"
    - "Excluded categories (Tied, Backbone_Only, Ambiguous) are visually dimmed in the report table"
    - "Scatter plot and box plot show all 5 categories with appropriate colors"
    - "When Backbone_Only and Ambiguous counts are 0, the report still renders correctly with those rows"
    - "Matplotlib backend generates plots with all 5 categories"
  artifacts:
    - path: "plasmicheck/templates/report_template.html"
      provides: "Updated read assignment table with 5 categories, visual indicators for excluded categories"
      contains: "Backbone_Only"
    - path: "plasmicheck/scripts/generate_report.py"
      provides: "Color mapping for new categories, passing new counts to template"
      contains: "backbone_only"
    - path: "plasmicheck/scripts/plotting/matplotlib_backend.py"
      provides: "Updated category lists and colors for matplotlib static plots"
      contains: "Backbone_Only"
  key_links:
    - from: "plasmicheck/scripts/generate_report.py"
      to: "plasmicheck/templates/report_template.html"
      via: "Jinja2 template rendering with new category variables"
      pattern: "backbone_only_count|ambiguous_count"
    - from: "plasmicheck/scripts/generate_report.py"
      to: "plasmicheck/scripts/plotting/colors.py"
      via: "ASSIGNMENT_COLORS dict used for color mapping"
      pattern: "ASSIGNMENT_COLORS"
    - from: "plasmicheck/scripts/plotting/matplotlib_backend.py"
      to: "plasmicheck/scripts/plotting/colors.py"
      via: "ASSIGNMENT_COLORS dict used for matplotlib plot colors"
      pattern: "ASSIGNMENT_COLORS"
---

<objective>
Update single-sample HTML reports to display new Backbone_Only and Ambiguous read categories with visual distinction between included and excluded categories.

Purpose: Fulfills FILT-05 by making the new read categories visible to users in reports with clear visual indicators showing which categories are included in the contamination ratio calculation.

Output: Updated report template with 5-category table, updated scatter/box plot color mappings, updated matplotlib backend for static plots.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-insert-region-aware-filtering/08-CONTEXT.md
@.planning/phases/08-insert-region-aware-filtering/08-RESEARCH.md
@.planning/phases/08-insert-region-aware-filtering/08-01-SUMMARY.md
@plasmicheck/scripts/generate_report.py
@plasmicheck/templates/report_template.html
@plasmicheck/scripts/plotting/matplotlib_backend.py
@plasmicheck/scripts/plotting/colors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update report template and report generation</name>
  <files>
    plasmicheck/templates/report_template.html
    plasmicheck/scripts/generate_report.py
  </files>
  <action>
  **1. Update `plasmicheck/templates/report_template.html`:**

  Replace the current summary section that renders `{{ summary_df|safe }}` with a structured read assignment table. The current template renders the summary DataFrame as a generic table. Replace the Summary section (the `<h2>Summary</h2>` block) with a custom read assignment table that distinguishes included from excluded categories.

  Replace:
  ```html
  <h2>Summary</h2>
  <div class="container">
      {{ summary_df|safe }}
  </div>
  ```

  With a structured table that shows read categories with visual distinction:
  ```html
  <h2>Read Assignment Summary</h2>
  <div class="container">
      <table class="table table-bordered" style="width: 60%; margin: 20px auto;">
          <thead>
              <tr>
                  <th>Category</th>
                  <th>Count</th>
                  <th>Proportion</th>
                  <th>Included in Ratio</th>
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td>Plasmid</td>
                  <td>{{ plasmid_count }}</td>
                  <td>{{ plasmid_pct }}%</td>
                  <td><span class="badge badge-success">Yes</span></td>
              </tr>
              <tr>
                  <td>Human</td>
                  <td>{{ human_count }}</td>
                  <td>{{ human_pct }}%</td>
                  <td><span class="badge badge-success">Yes</span></td>
              </tr>
              <tr class="text-muted">
                  <td>Tied</td>
                  <td>{{ tied_count }}</td>
                  <td>{{ tied_pct }}%</td>
                  <td><span class="badge badge-secondary">No</span></td>
              </tr>
              <tr class="text-muted">
                  <td>Backbone_Only</td>
                  <td>{{ backbone_only_count }}</td>
                  <td>{{ backbone_only_pct }}%</td>
                  <td><span class="badge badge-secondary">No</span></td>
              </tr>
              <tr class="text-muted">
                  <td>Ambiguous</td>
                  <td>{{ ambiguous_count }}</td>
                  <td>{{ ambiguous_pct }}%</td>
                  <td><span class="badge badge-secondary">No</span></td>
              </tr>
          </tbody>
          <tfoot>
              <tr>
                  <td><strong>Total</strong></td>
                  <td><strong>{{ total_reads }}</strong></td>
                  <td></td>
                  <td></td>
              </tr>
          </tfoot>
      </table>

      {% if backbone_warning %}
      <div class="alert alert-warning text-center" role="alert">
          {{ backbone_warning }}
      </div>
      {% endif %}
  </div>

  <h2>Additional Metrics</h2>
  <div class="container">
      <table class="table table-bordered" style="width: 60%; margin: 20px auto;">
          <tbody>
              <tr>
                  <td>Coverage Outside Insert Region</td>
                  <td>{{ coverage_outside_insert }}</td>
              </tr>
              <tr>
                  <td>Mismatches Near Insert Boundaries</td>
                  <td>{{ mismatches_near_insert }}</td>
              </tr>
          </tbody>
      </table>
  </div>
  ```

  The `text-muted` class (already available from Bootstrap 4.5.2 loaded in the template) provides visual dimming for excluded categories. The badge colors provide clear included/excluded indication.

  **2. Update `plasmicheck/scripts/generate_report.py`:**

  a) In `generate_report()` function, update the template rendering calls (both interactive and non-interactive) to pass individual category counts and percentages instead of the raw summary_df HTML. Extract values from summary_df before rendering:

  In the `main()` function, after loading data and extracting verdict/ratio, add extraction of new category counts:
  ```python
  # Extract category counts from summary_df
  def _get_count(df: pd.DataFrame, category: str) -> int:
      rows = df[df["Category"] == category]
      return int(rows["Count"].values[0]) if not rows.empty else 0

  plasmid_count = _get_count(summary_df, "Plasmid")
  human_count = _get_count(summary_df, "Human")
  tied_count = _get_count(summary_df, "Tied")
  backbone_only_count = _get_count(summary_df, "Backbone_Only")
  ambiguous_count = _get_count(summary_df, "Ambiguous")
  total_reads = plasmid_count + human_count + tied_count + backbone_only_count + ambiguous_count

  # Calculate percentages
  def _pct(count: int, total: int) -> str:
      return f"{count / total * 100:.1f}" if total > 0 else "0.0"

  # Extract additional metrics
  cov_rows = summary_df[summary_df["Category"] == "CoverageOutsideINSERT"]
  coverage_outside_insert = str(cov_rows["Count"].values[0]) if not cov_rows.empty else "N/A"
  mis_rows = summary_df[summary_df["Category"] == "MismatchesNearINSERT"]
  mismatches_near_insert = str(mis_rows["Count"].values[0]) if not mis_rows.empty else "N/A"

  # Determine if backbone filtering was unavailable
  backbone_warning = ""
  if backbone_only_count == 0 and ambiguous_count == 0:
      # Could be legitimate (no backbone reads) or unavailable -- check if coverage is N/A
      if coverage_outside_insert == "N/A" or coverage_outside_insert == "0.0000":
          backbone_warning = ""  # Don't warn if it looks like no data; only warn if explicitly logged
  ```

  b) Pass these values to `generate_report()` and through to `template.render()`. Add new parameters to the `generate_report()` function signature and pass them through:
  ```python
  plasmid_count=plasmid_count,
  human_count=human_count,
  tied_count=tied_count,
  backbone_only_count=backbone_only_count,
  ambiguous_count=ambiguous_count,
  total_reads=total_reads,
  plasmid_pct=_pct(plasmid_count, total_reads),
  human_pct=_pct(human_count, total_reads),
  tied_pct=_pct(tied_count, total_reads),
  backbone_only_pct=_pct(backbone_only_count, total_reads),
  ambiguous_pct=_pct(ambiguous_count, total_reads),
  coverage_outside_insert=coverage_outside_insert,
  mismatches_near_insert=mismatches_near_insert,
  backbone_warning=backbone_warning,
  ```

  IMPORTANT: Keep the existing `summary_df=summary_df.to_html(...)` parameter in the template.render() call for backward compatibility -- templates can fall back to it. But the NEW template should use the individual variables.

  c) Update color_discrete_map in `generate_plots()` for both scatter and box plots. Import ASSIGNMENT_COLORS from the colors module:
  ```python
  from .plotting.colors import ASSIGNMENT_COLORS
  ```
  Then in `generate_plots()`, add `color_discrete_map` to both Plotly figures:
  ```python
  fig_box = px.box(
      boxplot_df,
      x="AssignedTo",
      y="PlasmidScore",
      points="all",
      color="AssignedTo",
      color_discrete_map=ASSIGNMENT_COLORS,
      ...
  )

  fig_scatter = px.scatter(
      reads_df,
      x="PlasmidScore",
      y="HumanScore",
      color="AssignedTo",
      color_discrete_map=ASSIGNMENT_COLORS,
      ...
  )
  ```
  This ensures Backbone_Only and Ambiguous get their lightgray/darkgray colors from the shared color mapping defined in Plan 01.
  </action>
  <verify>
  Run: `make lint && make typecheck`
  Verify template renders: `python -c "from jinja2 import Environment, FileSystemLoader; env = Environment(loader=FileSystemLoader('plasmicheck/templates')); t = env.get_template('report_template.html'); print('Template OK')"` (no Jinja2 syntax errors)
  Run: `make test-fast` (all tests pass)
  </verify>
  <done>
  - report_template.html has structured 5-row read assignment table with text-muted for excluded categories, badge indicators, and percentage column
  - generate_report.py extracts and passes individual category counts/percentages to template
  - Plotly scatter/box plots use ASSIGNMENT_COLORS with all 5 categories mapped
  - Template renders without errors even when Backbone_Only and Ambiguous are 0
  </done>
</task>

<task type="auto">
  <name>Task 2: Update matplotlib backend for new categories</name>
  <files>
    plasmicheck/scripts/plotting/matplotlib_backend.py
  </files>
  <action>
  Update `generate_boxplot_matplotlib()` and `generate_scatter_matplotlib()` in the matplotlib backend to handle all 5 categories.

  **1. In `generate_boxplot_matplotlib()`:**
  Change the hardcoded categories list from:
  ```python
  categories = ["Plasmid", "Human", "Tied"]
  ```
  to:
  ```python
  categories = ["Plasmid", "Human", "Tied", "Backbone_Only", "Ambiguous"]
  ```
  The color lookup `ASSIGNMENT_COLORS.get(cat, "#999999")` already handles new entries since Plan 01 added them to `ASSIGNMENT_COLORS`.

  **2. In `generate_scatter_matplotlib()`:**
  Change the hardcoded categories list from:
  ```python
  categories = ["Plasmid", "Human", "Tied"]
  ```
  to:
  ```python
  categories = ["Plasmid", "Human", "Tied", "Backbone_Only", "Ambiguous"]
  ```
  Again, `ASSIGNMENT_COLORS.get(cat, "#999999")` handles the colors.

  Both functions already use `ASSIGNMENT_COLORS` for color lookup, so extending the categories list is sufficient. The functions will naturally handle the case where some categories have 0 reads (empty data slices produce no visual elements).
  </action>
  <verify>
  Run: `make ci-check`
  All checks must pass (lint, format, typecheck, tests).
  Verify the categories are updated: `grep -n "Backbone_Only" plasmicheck/scripts/plotting/matplotlib_backend.py` returns matches.
  </verify>
  <done>
  - matplotlib_backend.py boxplot and scatter functions iterate over all 5 categories
  - Static PNG plots will show Backbone_Only and Ambiguous when present
  - Empty categories (0 reads) render gracefully (no visual artifacts)
  - `make ci-check` passes cleanly
  </done>
</task>

</tasks>

<verification>
1. `make ci-check` passes (lint + format + typecheck + all tests)
2. Template renders: `python -c "from jinja2 import Environment, FileSystemLoader; env = Environment(loader=FileSystemLoader('plasmicheck/templates')); t = env.get_template('report_template.html'); print('OK')"`
3. New categories in template: `grep -c 'Backbone_Only\|Ambiguous' plasmicheck/templates/report_template.html` returns 4+ matches
4. Color mapping imported: `grep 'ASSIGNMENT_COLORS' plasmicheck/scripts/generate_report.py` has match
5. Matplotlib updated: `grep 'Backbone_Only' plasmicheck/scripts/plotting/matplotlib_backend.py` has matches
</verification>

<success_criteria>
- FILT-05: New categories (Backbone_Only, Ambiguous) displayed in single-sample HTML reports with counts and proportions
- Excluded categories visually distinguished from included categories via Bootstrap text-muted and badge styling
- Scatter/box plots show all 5 categories with appropriate gray tones for new categories
- Matplotlib backend produces static plots with all 5 categories
- Report renders correctly when Backbone_Only and Ambiguous counts are 0
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-insert-region-aware-filtering/08-02-SUMMARY.md`
</output>
