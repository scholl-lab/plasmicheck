---
phase: 09-coverage-metrics
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - plasmicheck/templates/report_template.html
  - plasmicheck/scripts/generate_report.py
  - tests/test_generate_report.py
autonomous: true

must_haves:
  truths:
    - "Single-sample HTML report contains a Coverage Analysis card with depth, breadth, and uniformity metrics"
    - "Coverage Analysis card displays insert and backbone metrics side by side"
    - "When all coverage values are zero, the card still renders with zero values displayed"
    - "When using whole-plasmid fallback, the card shows a warning: Insert region not defined"
    - "Existing report sections (verdict, stats, gauge, plots, read assignment, insert region analysis) are unchanged"
  artifacts:
    - path: "plasmicheck/templates/report_template.html"
      provides: "Coverage Analysis card in HTML report"
      contains: "Coverage Analysis"
    - path: "plasmicheck/scripts/generate_report.py"
      provides: "Coverage metric parsing from summary.tsv and template variable passing"
      contains: "MeanDepthInsert"
    - path: "tests/test_generate_report.py"
      provides: "Tests for coverage metric display in reports"
      min_lines: 10
  key_links:
    - from: "plasmicheck/scripts/generate_report.py"
      to: "summary.tsv"
      via: "parsing MeanDepthInsert, BreadthBackbone etc. from summary_df"
      pattern: "MeanDepthInsert|BreadthBackbone"
    - from: "plasmicheck/scripts/generate_report.py"
      to: "plasmicheck/templates/report_template.html"
      via: "template.render() with coverage_metrics dict"
      pattern: "coverage_metrics"
    - from: "plasmicheck/templates/report_template.html"
      to: "coverage_metrics template variable"
      via: "Jinja2 template rendering"
      pattern: "coverage_metrics"
---

<objective>
Display coverage metrics in the per-sample HTML report as a dedicated Coverage Analysis card.

Purpose: Users need to see coverage depth, breadth, and uniformity metrics directly in the interactive HTML report (not just in the summary.tsv file). This completes the Phase 9 deliverable for single-sample visibility.

Output: Updated report_template.html with a Coverage Analysis card, updated generate_report.py to parse and pass coverage metrics from summary.tsv, and updated report tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-coverage-metrics/09-CONTEXT.md
@.planning/phases/09-coverage-metrics/09-01-SUMMARY.md
@plasmicheck/scripts/generate_report.py
@plasmicheck/templates/report_template.html
@tests/test_generate_report.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parse coverage metrics in generate_report.py and pass to template</name>
  <files>
    plasmicheck/scripts/generate_report.py
  </files>
  <action>
    Update `plasmicheck/scripts/generate_report.py` to extract coverage metrics from summary_df and pass them to the template:

    1. In the `main()` function, after the existing metric extraction block (around line 575-578 where CoverageOutsideINSERT and MismatchesNearINSERT are extracted), add extraction of coverage metrics:

    ```python
    # Extract coverage metrics (Phase 9)
    def _get_metric(df: pd.DataFrame, category: str, default: str = "0.00") -> str:
        rows = df[df["Category"] == category]
        return str(rows["Count"].values[0]) if not rows.empty else default

    coverage_metrics = {
        "mean_depth_insert": _get_metric(summary_df, "MeanDepthInsert"),
        "median_depth_insert": _get_metric(summary_df, "MedianDepthInsert"),
        "breadth_insert": _get_metric(summary_df, "BreadthInsert"),
        "cv_insert": _get_metric(summary_df, "CoverageCV_Insert"),
        "mean_depth_backbone": _get_metric(summary_df, "MeanDepthBackbone"),
        "median_depth_backbone": _get_metric(summary_df, "MedianDepthBackbone"),
        "breadth_backbone": _get_metric(summary_df, "BreadthBackbone"),
        "breadth_backbone_5x": _get_metric(summary_df, "BreadthBackbone_5x"),
        "cv_backbone": _get_metric(summary_df, "CoverageCV_Backbone"),
    }
    ```

    2. Detect fallback mode: if MeanDepthBackbone is "0.00" AND BreadthBackbone is "0.00" AND MeanDepthInsert is NOT "0.00", this MIGHT be fallback, but we can't reliably detect it from summary.tsv alone. Instead, add a "CoverageFallback" row to summary.tsv (back in compare_alignments.py in Plan 01 -- but if Plan 01 didn't add it, detect by checking if a "CoverageFallback" row exists in summary_df):

    ```python
    coverage_fallback_rows = summary_df[summary_df["Category"] == "CoverageFallback"]
    coverage_fallback = not coverage_fallback_rows.empty and str(coverage_fallback_rows["Count"].values[0]).lower() == "true"
    ```

    If CoverageFallback row doesn't exist in summary.tsv, default coverage_fallback to False. This ensures backward compatibility with pre-Phase-9 summary files.

    Note: Plan 09-01 already writes a `CoverageFallback\tTrue|False` row to summary.tsv after coverage metrics. This task reads that row — no modification to compare_alignments.py needed.

    3. Add `coverage_metrics` dict and `coverage_fallback` bool as parameters to the `generate_report()` function signature. Add them as template variables in both interactive and non-interactive template.render() calls.

    4. Pass the variables through the call chain: main() -> generate_report() -> template.render(). The generate_report() function already has many keyword arguments; add:
    - `coverage_metrics: dict[str, str] | None = None` (default None for backward compat)
    - `coverage_fallback: bool = False`

    5. In both template.render() calls (interactive at ~line 415 and non-interactive at ~line 473), add:
    ```python
    coverage_metrics=coverage_metrics or {},
    coverage_fallback=coverage_fallback,
    ```

    6. Follow existing code patterns: the function signature is already long, add the new params at the end before the closing parenthesis. Match the existing style of extracting data from summary_df using conditional row matching.
  </action>
  <verify>
    Run `make lint && make typecheck` — no errors.
    Run `python -c "from plasmicheck.scripts.generate_report import main; print('import OK')"` — confirms module loads.
  </verify>
  <done>
    generate_report.py extracts coverage metrics from summary_df, passes them to template.render() as coverage_metrics dict and coverage_fallback bool. compare_alignments.py writes CoverageFallback row. All code passes lint and typecheck.
  </done>
</task>

<task type="auto">
  <name>Task 2: Coverage Analysis card in HTML template + report tests</name>
  <files>
    plasmicheck/templates/report_template.html
    tests/test_generate_report.py
  </files>
  <action>
    **1. Update report_template.html:**

    Add a "Coverage Analysis" card AFTER the existing "Insert Region Analysis" card (after line 602, before the "Run Details" section). The card should:

    - Use the existing `pc-card` class with `pc-card-header` reading "Coverage Analysis"
    - Show a fallback warning when coverage_fallback is true:
      ```html
      {% if coverage_fallback %}
      <div class="pc-notice" style="margin-bottom: 1rem;">
          Insert region not defined &mdash; metrics computed for whole plasmid
      </div>
      {% endif %}
      ```
    - Display a table with two data columns (Insert Region and Backbone) and metric rows:
      ```html
      <table class="pc-table">
          <thead>
              <tr>
                  <th>Metric</th>
                  <th class="pc-num">Insert Region</th>
                  <th class="pc-num">Backbone</th>
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td>Mean Depth</td>
                  <td class="pc-num">{{ coverage_metrics.mean_depth_insert | default('0.00') }}</td>
                  <td class="pc-num">{{ coverage_metrics.mean_depth_backbone | default('0.00') }}</td>
              </tr>
              <tr>
                  <td>Median Depth</td>
                  <td class="pc-num">{{ coverage_metrics.median_depth_insert | default('0.00') }}</td>
                  <td class="pc-num">{{ coverage_metrics.median_depth_backbone | default('0.00') }}</td>
              </tr>
              <tr>
                  <td>Breadth (1x)</td>
                  <td class="pc-num">{{ coverage_metrics.breadth_insert | default('0.00') }}</td>
                  <td class="pc-num">{{ coverage_metrics.breadth_backbone | default('0.00') }}</td>
              </tr>
              <tr>
                  <td>Breadth (5x)</td>
                  <td class="pc-num">&mdash;</td>
                  <td class="pc-num">{{ coverage_metrics.breadth_backbone_5x | default('0.00') }}</td>
              </tr>
              <tr>
                  <td>Uniformity (CV)</td>
                  <td class="pc-num">{{ coverage_metrics.cv_insert | default('0.00') }}</td>
                  <td class="pc-num">{{ coverage_metrics.cv_backbone | default('0.00') }}</td>
              </tr>
          </tbody>
      </table>
      ```
    - The card should always be visible (even when all values are zero per CONTEXT decision)
    - Use existing CSS classes (pc-table, pc-num, pc-notice) — no new CSS needed
    - The card should render gracefully when coverage_metrics is empty dict (Jinja2 `| default()` handles this)

    Note on Breadth (5x) for Insert: show mdash since insert breadth at 5x isn't separately tracked (only 1x breadth for insert is standard). If breadth_insert_5x IS available in the dict, show it instead. Use: `{{ coverage_metrics.breadth_insert_5x | default('&mdash;') | safe }}` — but ONLY use `| safe` on the mdash fallback, not on numeric values.

    Actually, simpler approach: show both insert and backbone at all thresholds. For Breadth (5x) insert row, use `{{ coverage_metrics.get('breadth_insert_5x', '&mdash;') }}`. Since Jinja2 dict doesn't have .get(), use the `| default` filter instead.

    **2. Update tests/test_generate_report.py:**

    Add test(s) that verify coverage metrics are passed through to the template:

    - **test_coverage_metrics_in_report**: Create a summary_df with coverage metric rows (use sample_summary_df_with_coverage fixture from conftest.py). Call `main()` with appropriate mock setup. Verify the output HTML file contains "Coverage Analysis" text and at least one metric value.

    - **test_coverage_metrics_missing_graceful**: Use the existing sample_summary_df fixture (no coverage rows). Verify the report still renders without error and the Coverage Analysis card shows default values.

    - **test_coverage_fallback_warning**: Create a summary_df with CoverageFallback=True. Verify the HTML contains "Insert region not defined" warning text.

    Follow existing test patterns in test_generate_report.py. Use tmpdir for output, mock plotly/plot generation as needed. The tests should focus on template rendering, not coverage computation (that's tested in test_coverage_metrics.py).
  </action>
  <verify>
    Run `make test-fast` — all tests pass.
    Run `make ci-check` — full CI pipeline passes.
  </verify>
  <done>
    report_template.html has a Coverage Analysis card after Insert Region Analysis. Card displays a table with Insert and Backbone columns showing mean depth, median depth, breadth (1x and 5x), and CV. Fallback warning shown when coverage_fallback is true. Card renders with defaults when coverage_metrics is empty. At least 3 new report tests pass.
  </done>
</task>

</tasks>

<verification>
1. `make ci-check` passes (lint + format + typecheck + all tests)
2. HTML report contains "Coverage Analysis" card with metrics table
3. Report renders without error when summary.tsv has no coverage rows (backward compat)
4. Report renders without error when all coverage values are zero
5. Fallback warning appears when CoverageFallback is True
</verification>

<success_criteria>
- Coverage Analysis card visible in per-sample HTML report
- Table shows Insert Region and Backbone columns with depth, breadth, CV metrics
- Card always visible (even with zero values per CONTEXT decision)
- Fallback warning displayed when insert region not defined
- Existing report sections completely unchanged
- All tests pass including 3+ new report-specific tests
</success_criteria>

<output>
After completion, create `.planning/phases/09-coverage-metrics/09-02-SUMMARY.md`
</output>
